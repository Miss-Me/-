<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[论文分享：A Proposed Visualization for Vulnerability Scan Data]]></title>
      <url>%2F2019%2F01%2F02%2F%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB%EF%BC%9AA-Proposed-Visualization-for-Vulnerability-Scan-Data%2F</url>
      <content type="text"><![CDATA[Title： A Proposed Visualization for Vulnerability Scan Data（针对漏洞扫描数据的建议可视化）原文作者： S Watson会议： Thirteenth Symposium on Usable Privacy and Security ({SOUPS} 2017)日期： 2017/6/20原文地址： https://www.usenix.org/system/files/conference/soups2017/wsiw2017-watson.pdf 0x01 论文背景&emsp;&emsp;基于通信和保护需求将系统分开的网络安全区域可以最大限度地降低安全风险，同时即使面对故障和安全事件，也可以继续保持信息流。&emsp;&emsp;通过基于角色的组织访问控制将风险和风险限制在每个区域，允许监控网络的人员更快地识别针对位于关键区域中的关键资产的可疑活动，并允许区域或子区域被锁定在违规事件或需要收容的事件。&emsp;&emsp;基于区域的体系结构，其中网络被布置成六个逻辑和/或物理上分离的区域。 根据需要，也可以在每个区域内配置子区域。对每个区域的访问由周边安全设备管理，例如防火墙。 &emsp;&emsp;不受信任区域包含不属于该组织的所有主机，包括Internet服务提供商。来自此区域的流量流入半可信（DMZ）区域，其中必须在外部公开的系统位于该区域中。这将包括组织的外部Web服务器。 &emsp;&emsp;受信任区域将包含所有内部公开的系统，例如员工桌面和笔记本电脑以及组织内部网。流量从它流入半透明区域并流向不可信区域，以便允许访问互联网的所有资源。 &emsp;&emsp;高风险的关键任务系统（例如保存受限组织数据的数据库服务器）将位于受限区域中。来自此区域的流量将流入受信任区域。 &emsp;&emsp;管理区域将包含管理组织的网络和安全性的所有系统。来自此区域的流量流入半可信，受信任和受限制的区域。 &emsp;&emsp;最后，审计区域将包含收集审计组织所需的日志和其他数据的所有系统。由于此数据高度敏感，因此流量仅从半信任，受信任和受限制的区域流入。 0x02 论文内容&emsp;&emsp;作者提出了一种基于安全区域的安全可视化建议，在基于区域的网络防御之上覆盖漏洞扫描数据的可视化，在实际网络布局的上下文中提供漏洞数据。 论文目标&emsp;&emsp;使用现有工具和技术、简单可视化方法来整合所需的上下文信息以帮助用户做出关键安全决策。 数据与工具&emsp;&emsp;使用了Rapid7 Nexpose扫描的同一子网中的35系统中的11,836个个体漏洞生成的扫描报告。 可视化输入&emsp;&emsp;用于图节点的文件，每个图节点对应于网络上的唯一设备，其中每个节点的IP地址被指定为节点id。 &emsp;&emsp;边缘的文件，表示与所表示的周边设备的所有连接，再次在文件中通过IP地址指定为从/到列。 &emsp;&emsp;带有原始漏洞数据的文件。 节点与边界 &emsp;&emsp;在图上使用标签来表示每个节点；使用给定节点的所有Nexpose严重性分数的平均值来确定其总体严重性分数，分数基于Common Vulnerability Scoring System计算。 A moderate vulnerability,（0-3.9）；只能在本地被利用，需要验证。这些漏洞几乎不会为攻击者提供受限信息，也不会提供攻击者破坏或破坏数据或导致系统中断的手段。 A severe vulnerability,（4.0-6.9）；只能被经验丰富的黑客利用，有或没有身份验证。这些漏洞将为攻击者提供对受限信息的部分访问，并可能提供攻击者破坏或破坏数据或导致系统中断的手段。 A critical vulnerability,（7.0-10.0）；只需很少甚至不需要身份验证即可轻松利用。这些漏洞将为攻击者提供对受限信息的完全访问权限，并提供攻击者可以破坏或破坏数据或导致系统中断的方法。 &emsp;&emsp;节点大小代表每个节点的整体漏洞风险，并根据为给定节点发现的严重漏洞和关键漏洞的数量计算。 &emsp;&emsp;放置在网络区域之间的线上的灰色节点表示在网络区域之间创建逻辑或物理分离的周边设备。 0x03 未来研究&emsp;&emsp;可视化在处理更大的网络和更复杂的关键性度量时进行扩展。&emsp;&emsp;评估可视化在交流和沟通方面对用户做出决策所做的贡献。 0x04 总结&emsp;&emsp;根据基于区域的网络防御架构，提出了一种建议的漏洞数据可视化分析方法。使用标签来表示节点，每个节点对应于实际网络中的一个设备；使用给定节点的所有Nexpose严重性分数的平均值来确定其总体严重性分数，分数基于Common Vulnerability Scoring System计算，分数在0.0到10.0之间，分成轻度（0-3.9）、严重（4.0-6.9）、关键（7.0-10.0）漏洞；节点大小代表每个节点的整体漏洞风险，并根据为给定节点发现的严重漏洞和关键漏洞的数量计算；放置在网络区域之间的线上的灰色节点表示在网络区域之间创建逻辑或物理分离的周边设备。 0x05 收获 了解了可视化在网络基础方面的具体应用。 可视化模型与实际网络结构的结合。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事件、事件代理、事件冒泡]]></title>
      <url>%2F2019%2F01%2F02%2F%E4%BA%8B%E4%BB%B6%E3%80%81%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E3%80%81%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%2F</url>
      <content type="text"><![CDATA[00x0 写在前面&emsp;&emsp;这是一篇总结博客。 00x1 事件与事件流 事件：HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。 事件流：事件流描述的是从页面中接受事件的顺序。事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程即DOM事件流。事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。 冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根。 捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即从DOM树的根到叶子。 &emsp;&emsp;“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，然后处于目标阶段，最后才事件冒泡。 00x2 事件冒泡&emsp;&emsp;IE在处理事件流的时候，事件的传播是按照从最特定的事件目标到最不特定的事件目标(document对象，有的浏览器是window)的顺序触发。这就是事件冒泡。123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;content&quot;&gt; &lt;button id=&quot;btn&quot;&gt;&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;在上面的代码中，如果点击了按钮“&lt; button &gt;”节点，那么接下来，“&lt; div &gt;”、“&lt; body &gt;”、“&lt; html &gt;”、document会按照先后顺序依次收到点击事件。&emsp;&emsp;事件冒泡仅仅传递的是事件触发，也就是说，当点击按钮button的时候仅仅触发了div、body、html、document的点击事件，并没有把自己绑定的函数传递给父级。父级的执行情况，还是取决于自己所绑定的函数。在父级没有绑定函数的情况下，并没有什么影响。但是在父级绑定了函数的情况下，冒泡就会带来一些困扰。这个时候就需要取消事件冒泡。 event.stopPropagation()：阻止事件的冒泡，不让事件向documen上蔓延，但是默认事件仍然会执行，当使用这个方法的时候，如果点击一个连接，这个连接仍然会被打开。该方法只阻止一次事件冒泡并且IE不支持此方法。IE取消事件冒泡要用e.cancelBubble=true。 event.preventDefault()方法：阻止默认事件，调用此方法时，链接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素。 return false ：这个方法比较暴力，会同时阻止事件冒泡和默认事件；写上此代码，连接不会被打开，事件也不会传递到上一层的父元素；可以理解为return false就等于同时调用了event.stopPropagation()和event.preventDefault()。 00x3 事件代理&emsp;&emsp;事件代理还可以叫事件委托，指的是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。&emsp;&emsp;比如在一个页面中，有100个button，每个button都有一个点击事件。那要怎么做呢，首先想到的是，我们可以给每个button onclick绑定点击事件，那这样就需要给每个button写一个onclick来进行绑定，增加了代码的重复度。再高级一点的方法呢，我们可以用dom来处理事件，使用for循环的方法，遍历所有的button，使用dom给他们添加点击事件。&emsp;&emsp;但是这个方式也不是最完美的，因为在JavaScript中，添加到页面上的事件处理程序数量会直接关系到页面的整体运行性能。for循环中需要不断地与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也越多，会延长整个页面的交互时间。性能优化的主要思想之一就是减少DOM操作。这个时候就可以利用事件代理，将所有操作放入js程序中，与DOM只交互一次，大大减少了与DOM的交互次数，提高了性能。123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;content&quot;&gt; &lt;button id=&quot;btn&quot;&gt;&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;事件代理是利用事件冒泡实现的。上面我们已经讲过，事件冒泡就是事件从最深的节点开始，然后逐步向上传播事件。当我们给button添加一个点击事件，这个事件会一层一层往外执行，div、body、html、document会一次收到这个事件。事件代理就是采用父级的div来做事件处理，由于冒泡原理，点击button事件会被冒泡到button的父级元素div上，如果div上添加的有点击事件，这时点击事件就会被触发；当然，点击div的时候，事件也是会触发的。那如果我们想让事件代理的效果跟直接给节点绑定的效果一样，需要怎么做呢？&emsp;&emsp;Event对象提供了一个target属性，可以返回事件的目标节点，成为事件源。我们可以将target理解为当前事件要操作的DOM，当然这并不是在真正地操作DOM。标准浏览器使用ev.target，IE浏览器用event.srcElement。此时只是获取了当前节点的位置，要想知道节点的名称，需要用nodeName来获取节点具体的标签名。需要注意的是，nodeName返回的值是大写的，习惯上把这个值转成小写的再使用。1234567891011window.onload = function()&#123; var div = document.getElementById(&quot;content&quot;); div.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &apos;button&apos;)&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125; &emsp;&emsp;经过这样修改后就只有在点击button的时候才会触发事件了，且每次只用执行一次DOM操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[论文分享：CommViz-Visualization of Semantic Patterns in Large Social Communication Network]]></title>
      <url>%2F2018%2F12%2F23%2F%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB%EF%BC%9ACommViz-Visualization-of-Semantic-Patterns-in-Large-Social-Communication-Network%2F</url>
      <content type="text"><![CDATA[Title： CommViz: Visualization of Semantic Patterns in Large Social Communication Networks（CommViz：大型社交网络中语义模式的可视化）原文作者： Karin Verspoor, Bahadorreza Ofoghi, Marlene Robles Granda期刊： Information Visualization日期： 2018/01/01原文地址： https://minerva-access.unimelb.edu.au/bitstream/handle/11343/127914/commviz-InfoVis.version-accepted.pdf?sequence=1可视化链接： http://commviz.eng.unimelb.edu.au 0x00 概览这篇文章介绍了一种信息可视化工具—CommViz，通过采用称为hive图的可视化方法来反映网络的语义结构，将其称之为语义蜂巢图。该方法有效地组织并提供对复杂的，高维度的通信数据的洞察，例如社交媒体上的电子邮件或消息。作者通过将CommViz工具的体系结构及其应用程序作为案例研究介绍给安然电子邮件语料库，演示了可视化结构如何能够调查大量消息中的模式和关系。 0x01 提出的问题及解决、文章目标、背景提出的问题及解决CommViz利用社交通信网络数据中的现有结构，例如电子邮件，即时消息或在线论坛 - 利用与每个单独消息相关联的元数据，指示发送者，接收者以及消息传输的日期和时间以及夫妻具有进一步上下文属性的结构，例如消息的推断主题内容（主题）或发送者的位置。 谁在给定的时间范围内向谁发送了关于什么主题的消息？ 人们在谈论什么主题以及何时讨论？ 哪些用户对特定主题进行了大量沟通？这对应于连接用户主题轴及其克隆的链接。 哪个主题与最大数量的邮件相关联？这可以通过源自用户主题轴的段中的链接的密度和暗度来观察。 在哪个时段是最常见的话题？通过查看源自用户主题轴并以用户时间轴轴结束的链接，可以观察到这一点。同样，坐标空间的该区域中的链接的密度和暗度表示重要的活动。 什么时候有最多的消息活动？这可以通过沿用户时间轴轴进入段的链接的密度和暗度来观察。 在给定的时间范围内，两个用户之间发送了多少条消息？这对应于连接用户时间轴和其克隆的链接。在这些轴之间的时间段内连接两个用户的暗链接指示当时两个用户之间的大量电子邮件。考虑图3中的安然数据集的概述。 CommViz方法解决了在二维表示中在单个链接中表示单个消息的四个核心属性的概念性挑战。 文章目标及贡献设计一个可视化，公开用户（发送者 - 接收者）交互的网络结构，同时整合这些交互的上下文和时间属性。通过案例研究和用户研究证明该工具可用于阐明网络中与感兴趣的特定分析问题相对应的有意义模式，文章中论证了语义蜂巢图的使用优于替代方法可视化这些通信网络。根据其属性组织消息，以便于检测与数据中的那些属性相关的有意义的模式，因此面临可视化高维多变量数据的问题。解决了在二维表示中在单个链接中表示单个消息的四个核心属性的概念性挑战。 相关工作及背景 大量节点和链接的可视化可能导致可视化中的“毛球”或“意大利面条”效应，具有大量的过度绘图，连接结构中的模式非常难以辨别。在图9中的代表性社交网络可视化中，可以观察到安全语料库中的这个问题，其将消息的人（发送者和接收者）显示为节点，并且当消息已经从一个人发送到另一个人时包括两个节点之间的链接。Hive图是作为“理性化”大型网络可视化的方法引入的，使用平行坐标图，其中轴是径向排列的，其中网络结构参数（如节点的聚类系数）用于将节点分配给轴，然后基于有序结构值（例如节点度或介于两者），将每个节点沿轴放置在可解释的坐标位置。蜂巢图在网络中的应用集中在根据网络本身的结构元素组织节点（即，定量网络结构测量）。所得到的可视化被认为是定量的，可视地可解析的和可缩放的。 已经开发了许多专门用于分析电子邮件的信息可视化系统，重点是电子邮件的元数据，包括旨在识别组织内的通信结构，线程结构或时间模式的工作。开发了很少的可视化系统考虑消息的上下文或内容。会话地图是一个早期系统，可视化Usenet的主题结构，提供社交网络，讨论主题和词汇关系的三个独立但相互连接的可视化。 主题模型通过应用概率图形模型得出，该概率图形模型推断在文档集合中聚集在一起的单词集合，以便发现代表集合中的文档的主题或主题。由于主题模型是对单词的概率分布，因此人们难以检查和验证。因此，已经努力促进主题的组织和可视化。这项工作主要侧重于主题的语料库级分析，包括TERMITE中主题模型中结构和术语关系的可视化，目的是支持对推断的主题质量的评估。其他工作，例如TopicMaps和TopicNets，已经解决了整个集合中主题和文档的连通性问题。许多其他工具，如Jigsaw和WordTree，也旨在揭示整个文档集文本中的模式，尽管它们不直接使用主题建模。 0x02 数据集及模型数据集及处理Enron email corpus（企业用户多年来发送的电子邮件） 该数据集最初包含属于158名安然员工的619,446封电子邮件，每位用户平均有757封邮件。 大多数信息都是由安然公司的高级管理人员发送的。数据集中的每个电子邮件对象都包含发件人和收件人的电子邮件地址，邮件正文，日期，时间和主题。经过处理之后，最终数据集包括89个人和56,210封电子邮件。 产生了四个核心维度：{sender, recipient, time, context}四个核心维度为了捕获此数据集中的上下文，我们应用称为主题建模的自然语言处理技术来确定文档集合的主题结构。 在对安然消息运行LDA之前，对文本应用了许多预处理步骤，包括标记化。令牌的小写，词形还原（使用斯坦福核心NLP工具），使用标准停用词列表删除停用词，以及删除非字母令牌（因为在主题建模的上下文中数字可能不具备信息）。电子邮件内容也经过预处理，以删除一些不相关的文本。具体而言，在转发电子邮件的情况下，剥离了电子邮件正文中包含的嵌入标题信息。 语料库模型应用主题建模的自然语言处理技术来确定文档的主题结构集合，并将每个电子邮件消息的内容与这些主题中的一个或多个相关联。使用Latent Dirichlet Allocation（LDA）方法，标准主题建模技术。 LDA中的主题由整个语料库词汇表中的术语列表上的不同分布表示。为了分析安然语料库并找到每封电子邮件消息的主题分布，使用了MAchine Learning for LanguagE Toolkit。 对于安全电子邮件的主题模型，LDA需要目标主题的数量作为其输入。实验中将主题总数设置为20，以用作可视化的初始目标集，而无需仔细调查最佳主题数。下表提供了MALLET在安然语料库中找到的主题（主题编号19）的示例，其中列出了该主题中概率最高的前10个术语。从该列表中，可以直观地确定该主题与能源定价有关。 alpha度量和令牌总数是主题的概率（在所有20个主题中总和为1.0）和语料库中与主题最相关的令牌总数。 12345678910111213&lt;topic id=’19’ alpha=’0.0232’totalTokens=’146261’&gt; &lt;word rank=’1’&gt;power&lt;/word&gt; &lt;word rank=’2’&gt;gas&lt;/word&gt; &lt;word rank=’3’&gt;market&lt;/word&gt; &lt;word rank=’4’&gt;price&lt;/word&gt; &lt;word rank=’5’&gt;plant&lt;/word&gt; &lt;word rank=’6’&gt;energy&lt;/word&gt; &lt;word rank=’7’&gt;year&lt;/word&gt; &lt;word rank=’8’&gt;project&lt;/word&gt; &lt;word rank=’9’&gt;cost&lt;/word&gt; &lt;word rank=’10’&gt;include&lt;/word&gt;&lt;/topic&gt; 在确定主题后，作者通过计算与每个主题相关联的电子邮件中的单词比例，将每封电子邮件映射到其最可能的主题。 可视化方案首先，就用户（在数据集中表示为发件人或收件人的个人）而言，我们已经开发了一个“可疑列表”，用于集中分析特定的个人子集。可疑列表中的每个个体都表示为可视化中的单个用户。其他安然内部用户（即，具有电子邮件地址@enron.com的用户）被组合在一起成为单个节点（节点1）。所有外部用户（非安然电子邮件地址）也组合在一起，形成一个节点（节点0）。 其次，如果电子邮件有多个收件人（例如，在：或：cc：列表中），我们会将该电子邮件视为连接发件人和每个收件人的多条（相同）个人邮件。 CommViz的核心可视化表示由两个主轴组成，每个主轴根据焦点问题，上下文或时间的一个方面表示数据集中的个体。对于焦点安全数据集，我们将上下文视为消息主题，由主题建模确定。 一个主轴线性划分为表示主题的段（每个线性段一个主题）。每个段包含一组表示电子邮件消息发送者的节点。对于安然数据集，每个段包含许多节点，这些节点等于安全数据集（或子样本）中的用户总数，并且轴具有与主题一样多的段。此轴上的每个节点代表可能已在给定主题上发送电子邮件的给定发件人。该轴称为用户主题轴。 第二主轴根据时间线性分段，因此在通信语料库中具有特定时间帧的段。发送消息的年份是沿此轴的安全数据集的初始分段结构。段中的每个节点表示在给定时间范围内可能的电子邮件收件人。我们称之为轴是用户时间轴的轴。连接CommViz中节点的链接（弧）表示特定时间范围内特定主题的通信。图1描述了应用于安然数据的可视化的基本结构，两个用户之间有一个示例弧。弧表示两个用户之间关于时间帧2中的主题2的电子邮件通信（表示一个或多个消息）。 该可视化结构的一个重要特征是沿一个轴的信息通过边缘的连通性传递到另一个轴上的节点。也就是说，沿时间轴的时间信息不仅适用于该轴上的节点。 ，它还会将主题和在该时间段内链接在另一个轴上的各个用户相关联。 这是因为单个链接代表发送者，接收者，时间范围，上下文的四倍。 此属性表示CommViz以直观有效的方式表示数据的四个维度。为了仅沿一个轴可视化用户交互（即，当不考虑另一个轴中的信息时），可以克隆蜂巢图中的每个轴。 下图显示了在使用克隆时我们为安然语料库采用的相同结构。 使用这种结构，可以专门理解在给定时间或关于给定主题的两个用户之间的交互。 评估可视化使用对照实验来比较不同的技术/工具或相同的技术与不同的设置或样式是最常见的可视化评估类型。 为CommViz采用的可视化评估类型是一个面向分析的任务，其中相同数据的两个不同可视化在支持用户正确回答数据驱动问题方面的有效性方面相互比较。将CommViz的有效性与Cytoscape中实现的竞争对手可视化方法的有效性进行了比较。 首先从与安然电子邮件语料库相关的每个可视化（CommViz和Cytoscape）中捕获了六个屏幕截图。 每个屏幕截图提供了回答特定类型问题所需的相同数据子集的视图。所有问题/图像在补充文件1和2中详述。问题涵盖数据集中的各种主题和日期信息。屏幕截图附有说明，以帮助用户理解问题的上下文，以及多项选择问题本身。 机械土耳其工人被要求从四个选项之一中选择一个答案，根据对数据的标准分析查询得知正确的答案。 用户以三种不同的随机确定的顺序之一回答了12个问题，如下表所示。 将12个问题的三个序列中的每一个与相应的描述和屏幕截图一起放入单个人类智能任务中（因此总共有三个HIT）。 每个HIT中的问题一次出现在屏幕上（带有问题编号，描述，可视化屏幕截图，问题和四个可能的答案选项），一旦他们回答，用户就无法返回上一个问题 它移动到下一个。每个HIT分别提交给Mechanical Turk，由50名不同的机械土耳其工人回答。我们为员工实施了多项资格标准，包括：允许工人只在每个HIT中回答一次问题。如果他们已经回答了另一个HIT的问题，那么工人就不被允许带任何其他HIT。工人必须拥有至少10,000个经批准的HIT。对于他们之前为Mechanical Turk的任何请求者完成的HIT，工人必须至少拥有98％的批准率。 可视化技术的有效性分析的第一个指标是准确性。每种可视化技术的总体准确度计算为参与给定HIT的50名个体工人的平均值。为了确定两个可视化的准确度值之间的差异是否具有统计显着性，文章在与每个HIT和整体相关的准确度值之间进行了配对t检验。 只考虑不同工作人员在回答每种可视化技术的数据驱动问题时的一致性。这可以解释为意味着具有Cytoscape可视化的用户之间的响应更加一致，但是这些响应通常是不正确的，即，用户被可视化以一致的方式误导。 首先，针对每个可视化计算平均Fleiss Kappa，并针对每个问题，与金标准答案进行比较。这侧重于为每个可视化的每个单独问题给出的答案。在这种情况下，存在六个一致值，每个问题一个与相同问题的黄金标准答案相比（即，两个主题和每个HIT的50个响应）。然后计算HIT的这六个协议值的平均值。下图为使用Cytoscape和CommViz获得的结果的准确性和评估者间协议分析。 每个准确度值前面的y符号表示该值与基于标准95％置信水平的配对t检验的竞争可视化的准确度之间的统计上显着差异。 在所有HIT和整体中，CommViz用户在测试问题上获得的统计上显着高于Cytoscape用户。其次，对于每个可视化，以及每个工人，与黄金标准答案相比，计算了平均Fleiss Kappa。这个kappa值强调用户的六个答案的平均一致性与六个问题的六个金标准答案，这六个问题伴随着每个可视化技术的屏幕截图。这个kappa值强调用户的六个答案的平均一致性与六个问题的六个金标准答案，这六个问题伴随着每个可视化技术的屏幕截图。为此，计算了两组六个答案之间的50个一致值（即，六个主题和两个评价者）。然后计算每个HIT的这50个协议值的平均值。下图给出了这两个一致性分析的结果。 进一步分析了单个问题级别的结果，以确定两种可视化技术中的每一种都表现出卓越的性能;换句话说，与另一个相比，使用一种可视化技术的用户可以更有效地回答什么类型的问题。每个可视化的准确性首先计算机械土耳其工人为每个问题给出的答案。与技术水平分析类似，每个问题的黄金标准答案用于计算准确性。结果表明CommViz使用户能够更有效地理解底层数据的信息内容。同时，使用CommViz可视化时，用户似乎更确定答案;与基于Cytoscape的可视化相比，用户响应的一致性更高。我们已经证明CommViz比标准的强制定向布局通信可视化具有重要的优势，特别是涉及上下文/主题之间或跨时间的比较分析的问题类型。 最后，展示了由150名机械土耳其工人选择的答案选项的分布，用（a）CommViz和（b）Cytoscape回答六个数据驱动的问题。 用数字标注的条形对应于问题的“正确”答案。 0x03 创新性 社交网络特征与基础数据的语义属性在单个可视化中的集成。 最初为生物网络可视化开发的称为hive图的可视化方法的改编，以实现通信网络结构的清晰表达。这种适应的新颖贡献是根据数据语义而不是网络结构的定量特征来绘制数据。因此，称之为适应语义蜂巢图。 在消息的sender，recipient，time元数据之外添加额外的信息性维度，特别是消息的上下文，也可以用于反映消息的内容。因此，可视化捕获社交网络结构，包括消息方向性以及消息特定的上下文。 在单个边缘中表示消息的所有四个属性，同时还支持在大型消息集合中探索涉及属性的不同子集的模式。该方法从语义蜂巢图扩展到语义坐标，其中轴被构造为同时捕获两个属性。 CommViz具有灵活，性此可视化方法不仅适用于邮件数据，还适用于即时消息或在线论坛 - 利用与每个单独消息相关联的元数据，指示发送者，接收者以及消息传输的日期和时间以及具有进一步上下文属性的结构，例如消息的推断主题内容（主题）或发送者的位置。文中通过将其应用于小型Twitter样本，并将其应用于来自VAST 2015 Mini-Challenge 2的“Dinofun World”访客通信数据。证明了其应用场景的灵活性。两种调整都可以在盲目的情况下查看*。 可视化的评估方面，做了大量丰富的对比实验。 0x04 未来工作 可以增强界面和可视化的许多方面，以向可视化的用户提供更直接的反馈。显然需要对当前安然应用程序进行改进，以提高分析师理解用户主题轴上的主题对应的能力。进一步建立在数据的语义特征上的一种增强是将用户分组到组织结构中，例如，基于团队，部门等，并根据用户级别，聚合这些组之间，之间和之内的消息流量。 可以改进用作主题组织消息的基础的主题建模算法。McCallum 为此提出了作者 -收件人-主题（ART）模型，并使用该模型证明了分类任务的改进。该模型可以用于改进主题建模本身，并且可以被利用来以连贯的方式组织轴段内的用户节点，即，就其角色而不是当前的任意排序。 允许分析师根据感兴趣的特定问题从基础数据的各种视图中进行选择。然后根据该选择生成主要和次要组织维度;Web服务将相应地生成节点和边缘及其分组。可视化足够灵活，可以支持沿不同轴的多个层次组，并且我们实现的Web服务方法允许根据需要动态生成这些不同的视图。 0x05 我的一些思考文章的一些不足 没有考虑如何最好合并一个额外的数据维度。在五个维度的时候，就不好表示了。 解释性问题。通过链接连接的轴之间的空间越大，越远离轴原点移动;可视化的评估解释。 时间动态问题。与主题相关的级别模式，例如，谁在谈论什么主题？如果没有明确表示代表中的个人，就不能轻易地进行查询。 文章的可借鉴的地方 可视化方案的评估方法；Fleiss Kappa一致性计算。 选取的邮件四个维度，文档主题模型的使用。 在其他领域的可视化方法的扩展。 克隆轴的提出。使用这种结构，可以专门理解在给定时间或关于给定主题的两个用户之间的交互。 可视化领域的一些点 提出一个新的可视化方法/算法；或者将别的领域的方法应用到当前领域中。 可视化模型及可视化方案。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Electron中主进程和渲染进程间的通信]]></title>
      <url>%2F2018%2F12%2F23%2FElectron%E4%B8%AD%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
      <content type="text"><![CDATA[0x00 写在前面&emsp;&emsp;在最近的项目中，用到了electron来进行桌面应用的开发。开发过程中涉及到从数据库中获取数据，并在页面中进行渲染这一过程。这一块也是electron开发中很重要的一个知识点：主进程和渲染进程间的通信。 0x01 主进程—ipcMain&emsp;&emsp;ipcMain模块是EventEmitter类的一个实例。 当在主进程中使用时，它处理从渲染器进程（网页）发送出来的异步和同步信息。 从渲染器进程发送的消息将被发送到该模块。 1. 发送消息 发送消息时，事件名称为channel。 回复同步信息时，需要设置event.returnValue。 将异步消息发送回发件人，需要使用event.sender.send(…)。 2. 方法&emsp;&emsp;IpcMain模块可以使用以下方法来侦听事件： ipcMain.on(channel[String], listener[Function]) &emsp;&emsp;监听一个事件，当接收到新的消息时 listener 会以 listener(event, args…) 的形式被调用。 ipcMain.once(channel[String], listener[Function]) &emsp;&emsp;这个方法只添加一次性的监听事件，当且仅当下一个消息发送到 channel 时 listener 才会被调用，随后 listener 会被移除。 ipcMain.removeListener(channel[String], listener[Function]) &emsp;&emsp;从监听器数组中移除监听事件(channel)指定的监听器(listener)。 ipcMain.removeAllListeners([channel][String]) &emsp;&emsp;删除所有监听者，或特指的 事件(channel) 的所有监听者. 3. 事件对象&emsp;&emsp;主进程向callback传递event对象可以有如下方法： event.returnValue &emsp;&emsp;在一个同步消息中使用该方法返回值. event.sender &emsp;&emsp;在一个异步消息中使用该方法返回值. 0x02 渲染进程—ipcRenderer&emsp;&emsp;ipcRenderer 是一个 EventEmitter 的实例。 可以使用它提供的一些方法从渲染进程 (web 页面) 发送同步或异步的消息到主进程。 也可以接收主进程回复的消息。 1. 方法&emsp;&emsp;ipcRenderer 模块可以使用以下方法来监听事件和发送消息。 ipcRenderer.on(channel[String], listener[Function]) &emsp;&emsp;监听事件(channel), 当新消息到达，将通过 listener(event, args…) 调用监听器(listener)。 ipcRenderer.once(channel[String], listener[Function]) &emsp;&emsp;为事件添加一个一次性用的监听器(listener) 函数.这个监听器 只有在下次的消息到达 事件(channel) 时被请求调用，之后就被删除了. ipcRenderer.removeListener(channel[String], listener[Function]) &emsp;&emsp;为特定的事件(channel)从监听队列中删除特定的 listener 监听者. ipcRenderer.removeAllListeners(channel[String]) &emsp;&emsp;移除所有的监听器，当指定 channel 时只移除与其相关的所有监听器。 ipcRenderer.send(channel[, arg1][, arg2][, …]) &emsp;&emsp;通过事件(channel)发送异步消息到主进程，可以携带任意参数。 在内部，参数会被序列化为 JSON，因此参数对象上的函数和原型链不会被发送。主进程可以使用 ipcMain 监听事件(channel) . ipcRenderer.sendSync(channel[, arg1][, arg2][, …]) &emsp;&emsp;返回任何由ipcMain处理程序发送过来的值。通过 channel 发送同步消息到主进程，可以携带任意参数。 在内部，参数会被序列化为 JSON，因此参数对象上的函数和原型链不会被发送。主进程可以使用 ipcMain 监听 channel来接收这些消息，并通过 event.returnValue 设置回复消息。需要注意的是: 发送同步消息将会阻塞整个渲染进程。 0x03 渲染进程—remote&emsp;&emsp;可以使用 remote 模块来调用 main 进程对象的方法,而不必显式发送进程间消息。也就是说，可以使用remote在渲染进程中使用主进程模块。比如，可以利用下面的代码在渲染进程中新建一个浏览器窗口。 1234//渲染进程const &#123;BrowserWindow&#125; = require(&apos;electron&apos;).remotelet win = new BrowserWindow(&#123;width: 800, height: 600&#125;)win.loadURL(&apos;https://miss-me.github.io/&apos;) 1. 远程对象&emsp;&emsp;remote 模块返回的每个对象 (包括函数) 表示主进程中的一个对象 (称之为远程对象或远程函数)。 当调用远程对象的方法时, 调用远程函数, 或者使用远程构造函数 (函数) 创建新对象时, 实际上是在发送同步进程消息。&emsp;&emsp;在上面的渲染进程中新建浏览器窗口时，BrowserWindow和win都是远程对象，new BrowserWindow并不是在渲染进程中创建BrowserWindow对象，而是在主进程中创建了一个BrowserWindow对象，并在渲染进程中返回相应的远程对象，即win对象。&emsp;&emsp;【注意】Electron确保只要渲染进程中的远程对象存在（换句话说，没有被垃圾收集），主进程中的相应对象将不会被释放。也就是说，当远程对象被垃圾回收后，主进程中的相应对象将被接触引用。在这种情况下，如果远程对象在渲染进程中泄露（存储在映射中，但从未释放），则主进程中的相应对象也将被泄露。 2. 访问主进程中的内置模块&emsp;&emsp;主进程中的内置模块被添加为 remote 模块中的获取器，因此可以像 electron 模块一样直接使用它们。 12const app = require(&apos;electron&apos;).remote.appconsole.log(app) 3. 方法 remote.require(module[String]) &emsp;&emsp;返回任何主进程中require(module) 返回的对象。 由其相对路径指定的模块将相对于主进程的入口点来解析。 123// main process: main/index.jsconst &#123;app&#125; = require(&apos;electron&apos;)app.on(&apos;ready&apos;, () =&gt; &#123; /* ... */ &#125;) 12// some relative module: main/foo.jsmodule.exports = &apos;bar&apos; 12// renderer process: renderer/index.jsconst foo = require(&apos;electron&apos;).remote.require(&apos;./foo&apos;) // bar remote.getCurrentWindow() &emsp;&emsp;返回 BrowserWindow - 此网页所属的窗口 remote.getCurrentWebContents() &emsp;&emsp;返回 WebContents - 此网页的 web 内容 remote.getGlobal(name[String]) &emsp;&emsp;返回任何主进程中 name (例如 global[name])的全局变量。 4. 属性 remote.process &emsp;&emsp;主进程中的 process 对象。这与 remote.getGlobal(‘process’) 相同, 但已被缓存。 0x04 进程间通信1. 同步消息 渲染进程 123const ipcRenderer = require(&apos;electron&apos;).ipcRenderer//引入ipcRendererconst reply = ipc.sendSync(&apos;synchronous-message&apos;, &apos;ping&apos;)//向&apos;synchronous-message&apos;事件发送一个异步消息：字段&apos;ping&apos; 主进程 12345const ipcMain = require(&apos;electron&apos;).ipcMain//主进程通过监听&apos;synchronous-message&apos;这个事件，接收渲染进程发送过来的值，也就是这里的argipcMain.on(&apos;synchronous-message&apos;, function (event, arg) &#123; event.returnValue = &apos;pong&apos;//向渲染进程返回一个值，同步返回消息&#125;) 2. 异步消息 渲染进程 12345678const ipcipcRenderer = require(&apos;electron&apos;).ipcRendereripc.send(&apos;asynchronous-message&apos;, &apos;ping&apos;)//渲染进程向主进程发送一个异步消息ipcRenderer.on(&apos;asynchronous-reply&apos;, function (event, arg) &#123;//渲染进程监听一个异步返回消息的事件，主进程返回的消息保存在arg里 const message = arg&#125;) 主进程 12345const ipcMain = require(&apos;electron&apos;).ipcMainipcMain.on(&apos;asynchronous-message&apos;, function (event, arg) &#123;//主进程监听来自渲染进程的异步消息，并返回一个消息 event.sender.send(&apos;asynchronous-reply&apos;, &apos;pong&apos;)//异步返回数据&#125;) 3. 使用remote通信123// 渲染进程//渲染remote接口直接获取渲染进程发送消息。remote.BrowserWindow.fromId(winId).webContents.send(&apos;ping&apos;, &apos;someThing&apos;); 12345678// 主进程//主进程创建事件，发送消息win1.webContents.send(&apos;distributeIds&apos;,&#123; win2Id : win2.id&#125;);win2.webContents.send(&apos;distributeIds&apos;,&#123; win1Id : win1.id&#125;); https://segmentfault.com/a/1190000009253100 4. 渲染进程间的通信&emsp;&emsp;使用 ipcRenderer.sendTo() 在渲染进程中互相发送通信，更加容易。1ipcRenderer.sendTo(windowId, &apos;ping&apos;, &apos;someThing&apos;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用Vuex管理websocket实时推送的数据，实现全局提示]]></title>
      <url>%2F2018%2F12%2F08%2F%E7%94%A8Vuex%E7%AE%A1%E7%90%86websocket%E5%AE%9E%E6%97%B6%E6%8E%A8%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E6%8F%90%E7%A4%BA%2F</url>
      <content type="text"><![CDATA[0x00 写在前面&emsp;&emsp;最近的项目中用到了websocket实现实时通信。遇到了一个问题：如何将websocket服务器端实时推送过来的数据全局实时推送。由于websocket通信的实时性和vue中的渲染机制。在查了很多资料之后，发现vuex是实现这个功能的最佳选择。 &emsp;&emsp;上图中展示了一个状态自管理应用中的单向数据流。由 state，驱动应用的数据源；view，以声明方式将 state 映射到视图；actions，响应在 view 上的用户输入导致的状态变化 三部分组成。当遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏： 多个视图依赖于同一状态。 来自不同视图的行为需要变更同一状态。 &emsp;&emsp;这时，将组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！这就是vuex的设计思想。 0x01 什么是vuex？&emsp;&emsp;vue官方说法中，Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&emsp;&emsp;如上图所示，Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便跟踪每一个状态的变化。 0x02 关于State&emsp;&emsp;Vuex 使用单一状态树：用一个对象包含全部的应用层级状态。由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态： 123456789// 创建一个 Counter 组件const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return store.state.count &#125; &#125;&#125; &emsp;&emsp;每当 store.state.count 变化的时候,都会重新求取计算属性，并且触发更新相关联的 DOM。这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。 &emsp;&emsp;Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）。通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。 &emsp;&emsp;当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。这时可以使用 mapState 辅助函数帮助我们生成计算属性。 123456789101112131415161718// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from &apos;vuex&apos;export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count` countAlias: &apos;count&apos;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 0x03 关于Mutations&emsp;&emsp;提交 mutation是更改Vuex 的 store 中的状态的唯一方法。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) &emsp;&emsp;mutation handler不能直接被调用，Mutations以相应的type通过调用store.commit(‘increment’)触发 mutation handler 1store.commit(&apos;increment&apos;) 0x04 关于Actions&emsp;&emsp;Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&apos;increment&apos;) &#125; &#125;&#125;) &emsp;&emsp;Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此可以通过调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。实践中，经常会用到 ES2015 的 参数解构 来简化代码（特别是需要多次调用 commit 的时候）：12345actions: &#123; increment (&#123; commit &#125;) &#123; commit(&apos;increment&apos;) &#125;&#125; &emsp;&emsp;Action 通过 store.dispatch 方法触发： 1store.dispatch(&apos;increment&apos;) &emsp;&emsp;这个方式就体现了action与mutation 的不同之处：mutation 必须同步执行，而Action 就不受约束！可以在 action 内部执行异步操作：1234567actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&apos;increment&apos;) &#125;, 1000) &#125;&#125; 0x05 项目中的思路&emsp;&emsp;项目结构如下所示：其中Web.vue是整个页面的根组件，于是我将websocket的实时通信写在了这里。&emsp;&emsp;在建立连接之后，当有用户上线，后端就向前端实时推送数据，并使用this.$store.dispatch将后端推送的数据保存为store里的一个state。 1、实时通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748methods:&#123; initWebSocket()&#123; // 打开一个 web socket this.ws = new WebSocket(&quot;ws://ip:port&quot;); this.ws.onopen = this.websocketsend; this.ws.onmessage = this.websocketonmessage; this.ws.onclose = this.websocketclose; &#125;, websocketsend(agentData)&#123;// Web Socket 已连接上，使用 send() 方法发送数据 this.ws.send(agentData); &#125;, websocketonmessage(evt) &#123; var data = eval(&quot;(&quot;+evt.data+&quot;)&quot;); var type =data.type || &apos;&apos;; var action = data.action; var id = data.client_id; // 后端php文件中中返回的init类型的消息，将client_id发给后台进行uid绑定 // 利用jquery发起ajax请求，将client_id发给后端进行uid绑定 // console.log(evt); if(type == &apos;init&apos;)&#123; $.ajax(&#123; //这里使用了jQuery的同步通信来提交用户id，是根据后端websocket框架使用的websocket通信连接验证及建立的方式来的。 type: &apos;POST&apos;, url: &quot;./index.php/bind&quot;, //?client_id=&quot;+data.client_id+&quot;&amp;token=&quot;+sessionStorage.token async: false, dataType:&apos;json&apos;, data:&#123;client_id: id,token:sessionStorage.token&#125;, success: function(data)&#123; // console.log(data); //第一次连接建立之后，就启动一个dispatch将当前返回的cookie存到vuex的全局变量中去。 this.$store.dispatch(&apos;dataPush&apos;, data).then(() =&gt; &#123; &#125;) &#125; &#125;); // console.log(&quot;请求后&quot;); &#125;else if(action == &apos;ping&apos;)&#123; this.websocketsend(&quot;pong&quot;); &#125;else&#123; // console.log(evt.data); this.$store.dispatch(&apos;dataPush&apos;, evt.data).then(() =&gt; &#123; &#125;) &#125; &#125;, websocketclose(e)&#123; // 关闭 websocket console.log(e); &#125;,&#125; &emsp;&emsp;然后，在src文件夹下新建一个/store/index.js文件，引入vuex来进行全局状态管理。在state里面定义一个全局变量data。在mutations里面定义一个dataPush函数，更改state状态。当接收到新用户上线的数据推送时，就会触发store里面的dataPush函数，修改store里面的数据状态。12345678910111213141516171819202122232425262728import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; // 全局变量 state: &#123; data: undefined &#125;, // 修改全局变量必须通过mutations中的方法 // mutations只能采用同步方法 mutations: &#123; dataPush (state, payload) &#123; state.data = payload; &#125; &#125;, // 异步方法用actions // actions不能直接修改全局变量，需要调用commit方法来触发mutation中的方法 actions: &#123; dataPush (context, payload) &#123; context.commit(&apos;dataPush&apos;, payload) &#125; &#125;&#125;)export default store &emsp;&emsp;最后，在web.vue页面建立一个监听事件，监听$store.state.data这个状态是否有更新，如果有更新，就使用一个提示组件，展示新上线的用户信息。 1234567891011121314watch:&#123;//监听vuex中更新的data数据 &quot;$store.state.data&quot;:function () &#123; var data = JSON.parse(this.$store.state.data); // &quot;uid&quot;:&quot;xxxxxxx&quot;,&quot;eventid&quot;:&quot;xxxxxxxxxxxxxxxxxxx&quot;, // &quot;sessdate&quot;:&quot;&quot;,&quot;ip&quot;:&quot;&quot; this.$Notice.warning(&#123; title: &apos;客户端上线&apos;, desc: &quot;ip:&quot;+data[&quot;ip&quot;]+&quot;&lt;br&gt;uid:&quot;+data[&quot;uid&quot;]+&quot;&lt;br&gt;eventid:&quot;+data[&quot;eventid&quot;]+&quot;&lt;br&gt;sessdate:&quot;+data[&quot;sessdate&quot;], duration: 0 &#125;); &#125;&#125;,]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react+electron+ant-design+sqlite3实现一个桌面应用]]></title>
      <url>%2F2018%2F12%2F04%2Freact-electron-ant-design-sqlite3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[0x00 写在前面&emsp;&emsp;最近帮隔壁实验室写个简单的展示页面，想着自己学了一下nodejs与react，刚好可以用来练练手。于是使用sqlite3数据库，用nodejs来写后端，react写前端的前后端分离方法，完成了一个小demo。这时候又要求用electron改成桌面版的应用，这简单啊，把react打包出来的index.html放到electron下做入口文件不就OK了。但是又涉及到跟对方的Java环境下的jar包通信的问题，对方的思路是通过前端点击按钮在数据库里存入一个字段，jar包所在环境通过不断轮询数据库去获取该字段确定是否启动手机应用拖数据库。前端在点击按钮后不断轮询数据库，看需要的数据是否更新，有数据更新就取回数据，并在前端展示。对于这个方案，我是拒绝的。回来跟师兄讨论了一下，确定了下几种方案。 nodejs写后端，react写前端。前端请求后端，由nodejs命令行启动jar。打包react页面放到electron下作为入口文件。 nodejs写后端，react写前端。把react页面打包近electron下作为入口文件，由于electron是基于nodejs的，所以在electron里使用socket实现桌面应用与jar包通信。 Java写后端，react写前端。把react写的页面打包放进electron下作为入口文件，放入Java环境下。 整合electron与react框架。使用ipcMain与ipcRenderer实现进程间的通信，ipcMain（主进程）用来获取数据，启动jar获取返回，再将数据返回到ipcRenderer(渲染进程)进行渲染。 &emsp;&emsp;前三种方式都是需要启动服务器端的，对方采用sqlite3做数据库，就是希望在不启动服务器的情况下打开应用，启动jar包，展示数据。因此，第四种方式是最合适的。但是在整合electron与react框架时，出现了很多问题。其中最关键的问题就是整合后react中不能直接使用require引入ipcRenderer。目前网络上查到的解决方案，都是使用window.require引入，同时使用预加载的方式。但是这种方式只适合在不使用进程间通信的情况下使用。下面给出一种我尝试成功的方法，可以使用进程间通信。虽然在开发过程中也出现了很多问题，但是所幸都一一解决了。 0x01 技术路线 技术路线 用途 Electron 构建桌面应用 react 前端页面渲染，展示 ant design React的UI库 sqlite3 一个轻量级的数据库 0x02 环境安装及配置 首先确认已经安装了Nodejs环境，如果没有安装请自行在搜索相关文章进行安装，这里不做详细讲解。 新建项目，打开cmd 123mkdir my-reactcd my-reactnpm init//默认配置就好 安装依赖 1234npm install –save-dev electron electron-prebuilt electron-reload electron-packagernpm install –save-dev babel babelify babel-preset-es2015 babel-preset-react babel-plugin-transform-es2015-spreadnpm install –save-dev browserify watchifynpm install –-save react react-dom react-router-dom &emsp;&emsp;推荐ant design按需加载，因此这里还需要安装babel-plugin-import。12npm install antd --savenpm install –save-dev babel-plugin-import &emsp;&emsp;具体配置和使用请参考ant design官网. 配置.babel &emsp;&emsp;在根目录下新建一个.babelrc文件，内容如下：123456789&#123; &quot;presets&quot;: [ &quot;es2015&quot;, &quot;react&quot; ], &quot;plugins&quot;: [ &quot;transform-object-rest-spread&quot; ]&#125; &emsp;&emsp;这两项用来告知babel转换ES6和React JSX风格的代码，另外还需转换ES6中的spread语法。 代码转换 &emsp;&emsp;package.json 文件中配置 watchify，让其可以自动检测本地代码变化，并且自动转换代码。&emsp;&emsp;scripts 下面配置了三个命令：start、watch、package，分别用于启动 App、检测并转换代码、打包 App。12345&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot;, &quot;watch&quot;: &quot;watchify app/appEntry.js -t babelify -o public/js/bundle.js --debug --verbose&quot;, &quot;package&quot;: &quot;electron-packager ./ DemoApps --overwrite --app-version=1.0.0 --platform=win32 --arch=x64 --out=../DemoApps --electron-version=1.4.13 --app-version=1.2.1 --icon=./public/img/icon/icon.ico&quot;&#125;, &emsp;&emsp;通过在命令行下执行 npm run xxx ，可以运行上面定义好的命令。我们看到，通过 babelify 将代码转换输出到 public/js/bundle.js 目录下，所以我们发布时只需要这一个转换好的 js 文件即可。 0x03 Electron&emsp;&emsp;package.json文件中有一个”main”字段，这指明了主进程的入口文件。也就是说，启动Electron后会首先在主进程中加载执行这个js文件。所以我们要在这里创建窗口，并在这里指定页面加载的入口文件（index.html）。 index.js 123456789101112131415161718192021222324&apos;use strict&apos;;const electron = require(&apos;electron&apos;);const &#123;app, BrowserWindow, Menu, ipcMain, ipcRenderer&#125; = electron;var mainWnd = null;function createMainWnd() &#123;//创建主进程的窗口 mainWnd = new BrowserWindow(&#123;//长宽可以自定义设置 width: , height: , icon: &apos;public/img/app-icon.png&apos; &#125;); if (isDevelopment) &#123; mainWnd.webContents.openDevTools(); &#125; mainWnd.loadURL(`file://$&#123;__dirname&#125;/index.html`);//加载index.html，打开electron将会显示index.html的内容 mainWnd.on(&apos;closed&apos;, () =&gt; &#123; mainWnd = null; &#125;);&#125;app.on(&apos;ready&apos;, createMainWnd);app.on(&apos;window-all-closed&apos;, () =&gt; &#123; app.quit();&#125;); index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Electron Demo Apps&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;public/css/main.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;/div&gt; &lt;!--引入转换后的js--&gt; &lt;script src=&quot;public/js/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; &emsp;&emsp;这里的id为root的div是一个容器，React组件将会渲染到这个div上面；引入的bundle.js是通过babelify转换生成的js文件。 app/appEntry.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&apos;use strict&apos;;import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &#123; BrowserRouter as Router, Route, Link, Switch, Redirect&#125; from &apos;react-router-dom&apos;;import Homepage from &apos;./components/Homepage&apos;; // 导入首页组件import Device from &apos;./components/Device&apos;; // 导入设备组件import &#123; Layout, Menu &#125; from &apos;antd&apos;;const &#123; Header, Content, Footer &#125; = Layout;const electron = window.require(&apos;electron&apos;);const &#123; ipcRenderer, shell &#125; = electron;class MainWindow extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;!--这是路由组件--&gt; &lt;Router&gt; &lt;Layout className=&quot;layout&quot;&gt; &#123;/* &lt;div className=&quot;logo&quot; /&gt; */&#125; &lt;Header&gt; &lt;div className=&quot;logo&quot; /&gt; &lt;Menu theme=&quot;dark&quot; mode=&quot;horizontal&quot; defaultSelectedKeys=&#123;[&apos;1&apos;]&#125; style=&#123;&#123; lineHeight: &apos;64px&apos; &#125;&#125; &gt; &lt;Menu.Item key=&quot;1&quot;&gt; &lt;Link to=&quot;/service&quot;&gt;服务&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=&quot;2&quot;&gt; &lt;Link to=&quot;/homepage&quot;&gt;首页&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;/Menu&gt; &lt;/Header&gt; &lt;Content style=&#123;&#123; padding: &apos;0 50px&apos; &#125;&#125;&gt; &lt;div style=&#123;&#123; background: &apos;#fff&apos;, padding: 24, minHeight: 880 &#125;&#125;&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Service&#125;&gt; &lt;/Route&gt; &lt;Route path=&quot;/homepage&quot; component=&#123;Homepage&#125; /&gt; &lt;Redirect to=&quot;/&quot; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Content&gt; &lt;Footer style=&#123;&#123; textAlign: &apos;center&apos; &#125;&#125;&gt; Ant Design ©2018 Created by Ant UED &lt;/Footer&gt; &lt;/Layout&gt; &lt;/Router&gt; ); &#125;&#125;let mainWndComponent = ReactDOM.render( &lt;MainWindow /&gt;, document.querySelector(&apos;#root&apos;)); &emsp;&emsp;需要注意的是，这里的ant design要按需引入；同时为了实现路由，要引入react-router-dom的组件；引入nodejs中文件处理的一些模块；引入electron的渲染进程，用于和主进程进行通信。并通过ReactDOM.render 方法将一个 React 组件渲染到了一个 div 上面。 0x04 sqlite3安装&emsp;&emsp;Electron是基于nodejs的，sqlite3又是一个轻量级数据库。所以这里我们通过在Electron里安装sqlite3的依赖，并引入sqlite3模块来使用它。 &emsp;&emsp;但是在安装过程中会出现很多问题，其中比较多的就是在Electron中对sqlite3的编译问题。下面给出一个测试正确的方法。 &emsp;&emsp;首先是安装环境。先安装python2.7环境，只能是2.7的环境，sqlite3在大于2.7的环境中无法正确编译；其次安装vs2015，只能是2015版本，2017不行。安装完之后一定要安装vs2015所需的C++开发环境，这点很重要，因为要是没有这个东西，会报错，缺少v140的工具集，之所以没有选择vs2017，是由于vs201没有v140的工具集。这一步的安装工作非常非常非常重要！！！！如果环境安装不正确，使用后面的命令将会报错！！！！ &emsp;&emsp;然后使用Microsoft的windows-build-tools，在确认电脑安装了python2.7版本的情况下（python3.0以上版本不支持），以管理员身份运行PowerShell或CMD.exe。使用下面代码安装所有必需的工具和配置。环境没有安装好这一步将会报错！！！！ 1cnpm install -g windows-build-tools &emsp;&emsp;然后安装sqlite3及相关依赖12345678cnpm install sqlite3 --savecnpm install node-gyp -gcnpm install nan --savecnpm install electron-rebuild --save &emsp;&emsp;最后进行编译。 12345.\node_modules\.bin\electron-rebuild.cmdcd .\node_modules\sqlite3node-gyp rebuild --target=1.4.13 --arch=x64 --target_platform=win32 --dist-url=https://atom.io/download/electron/ --module_name=node_sqlite3 --module_path=../lib/binding/electron-v1.4-win32-x64 &emsp;&emsp;上面的target是electron版本，可以通过1electron -v 命令来查看。&emsp;&emsp;还有一点需要注意的是，上面有两个地方用到了electron的版号，一个是’–target’中，这里需要完整的版本号；另一个是module_path中有一个electron-v1.4字段，module_path是编译生成的node_sqlite3.node所在的路径，electron-v1.4-win32-x64是node_sqlite3.node上一级文件名，这里只能用v1.4不能用1.4.13，否则会生成名为electron-v1.4.13-win32-x64的文件夹。在启动项目时，项目会默认查找electron-v1.4-win32-x64文件夹中的node_sqlite3.node文件，会因为找不到该文件而报错。如果使用了electron-v1.4.13，一定要到相应的文件夹中把名字改成electron-v1.4-win32-x64。切记切记！！！ 0x05 启动&emsp;&emsp;首先启动Watchify，主要是让其监控本地文件修改，实时转换生成 public/js/bundle.js 文件。如果appEntry.js转换成bundle.js有错误的话，命令行下也会有提示。 1npm run watch &emsp;&emsp;接下来就需要调用start来启动App了。 1npm run start 0x06 数据库操作与页面渲染&emsp;&emsp;在这个项目中，我们使用到进程间通信来获取数据，并渲染到页面上。主进程用ipcMain，负责从sqlite3数据库获取数据，再通过与渲染进程ipcrenderer通信，将数据返回给渲染进程，渲染到页面上。 主进程index.js中1234567891011121314151617181920212223242526272829ipcMain.on(&apos;getServiceMsg&apos;, (event, arg) =&gt; &#123;//主进程监听一个渲染进程，进行数据库操作 let curpage = arg.curpage; let sql_num = &quot;SELECT * from Info&quot;; let sql_all = &quot;SELECT * from Info limit 1&quot; ; let num; let results = []; db.all(sql_num, function (err, rows) &#123; num = rows.length; &#125;); db.all(sql_all, function (err, rows) &#123; console.log(rows); rows.map((row) =&gt; &#123; results.push(&#123; &quot;key&quot;: row.id, &quot;xinghao&quot;: row.xinghao, &quot;bianhao&quot;: row.bianhao, &quot;yuyan&quot;: row.yuyan, &quot;changshang&quot;: row.changshang &#125;) &#125;) results.push(&#123; &quot;count&quot;: num, &quot;curpage&quot;: curpage &#125;); // console.log(results); event.returnValue = results;//将从数据库取得的数据返回给渲染进程 &#125;);&#125;) &emsp;&emsp;主进程需要对这个字段进行监听。 渲染进程Homepage.js中1234567891011121314151617181920212223242526272829303132333435export default class Hello extends Component&#123; constructor(props) &#123; super(props); this.state = &#123; dataSource: [], total: &quot;&quot;, curpage: 1, Selected: &quot;&quot; &#125;; &#125; componentDidMount() &#123; this.getMessageData(); &#125; getMessageData() &#123; let data = &#123; &quot;type&quot;:&quot;Info&quot;, &quot;curpage&quot;:this.state.curpage &#125; let res = ipcRenderer.sendSync(&apos;getServiceMsg&apos;, data);//发送给主进程一个字段：&apos;getServiceMsg&apos;，执行数据库查询操作后会获取一个返回值。 let count = res.pop(); this.setState(&#123; dataSource: res[0], total: count.count &#125;, () =&gt; &#123; console.log(this.state.dataSource); &#125;); &#125; onChange(page) &#123; this.setState(&#123; curpage: page.current, &#125;, () =&gt; &#123; this.getMessageData(); &#125;); &#125; render()&#123;&#125; 0x07 开发过程中出现的一些问题 css样式的问题：在用react开发的js文件中引用外部的css文件会报错；antd.css样式不能渲染。这应该是因为babel将appEntry.js转换成bundle.js文件，并没有将css文件转化出来。页面是通过加载index.html进行渲染的，html文件中不能找到css文件。因此，在入口html文件中引入外部css文件。可以解决这个问题。 文件路径问题：文件夹app下存放的是用react开发的js文件，在这里面引入图片时使用相对路径会出错。首先，Homepage与Device两个页面放在app文件夹下的components下，在app文件夹中，js文件的根路径就是app文件夹；因此，引入的图片只能放在app文件夹或下一级目录下；其次，经过babel的转化引起，在bundle.js文件中找不到合适的路径。因此，在引入图片时，我使用了绝对路径或者在整个项目的根目录下写一个css文件，在类中引入图片。 路由的问题：在打开页面时，首页是空白的，只有通过点击导航栏，才会将页面渲染出来。这个问题的解决请参考我前面的博客。 window.require问题：在react中不能直接引入ipcRenderer。这里要使用window.require进行引入，但需要注意的是，打包后的index.html文件为空白，会出现，’window.require is not a function’的报错，使用window.require而不是require来避免electron和browserify的require函数之间的冲突。在浏览器测试的时候会报错，这是因为window.require未在浏览器中定义，只在运行Electron应用程序时起作用。 0x08 打包&emsp;&emsp;关于electron的打包，目前提供了两种打包方式。这里使用的是electron-package。可以参考我的另外一篇博客electron与vue实践初体验。&emsp;&emsp;这里只给出命令 package.json/scripts1electron-packager ./ DemoApps --overwrite --app-version=1.0.0 --platform=win32 --arch=x64 --out=../DemoApps --electron-version=1.4.13 --app-version=1.2.1 --icon=./public/img/icon/icon.ico &emsp;&emsp;需要注意的是，前面00x4中对sqlite3编译时用到了–arch=x64，所以对应的，这里的arch也要用x64，如果用别的可能会报错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器存储的三种方式------Cookie、localStorage和SessionStorage]]></title>
      <url>%2F2018%2F12%2F04%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-Cookie%E3%80%81localStorage%E5%92%8CSessionStorage%2F</url>
      <content type="text"><![CDATA[0x00 写在前面&emsp;&emsp;这是不得不写的一篇。 0x01 Cookie&emsp;&emsp;当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。Cookie 的作用就是用于解决 “如何记录客户端的用户信息”: 当用户访问 web 页面时，用户名可以记录在 cookie 中。 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。 &emsp;&emsp;Cookie 以名/值对形式存储，当浏览器从服务器上请求 web 页面时， 属于该页面的 cookie 会被添加到该请求中。服务端通过这种方式来获取用户的信息。 1username=John Doe 创建Cookie 123document.cookie=&quot;username=John Doe&quot;;document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT&quot;;//为Cookie创建一个过期时间document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;//使用path参数告诉浏览器Cookie的路径 读取Cookie 1var x = document.cookie;//以字符串的方式返回所有的cookie 修改Cookie 1document.cookie=&quot;username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;//类似于创建Cookie，旧的Cookie将会被覆盖。 删除Cookie &emsp;&emsp;设置express参数为以前的时间。1document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;; 0x02 localStorage&emsp;&emsp;localStorage是HTML5中新加入的特性，用来作为本地存储的，解决了cookie存储空间不足的问题。localStorage 类似于sessionStorage。区别在于: localStorage - 没有时间限制的数据存储 sessionStorage - 针对一个 session 的数据存储,当页面被关闭时,数据存储在sessionStorage 会被清除 。 &emsp;&emsp;localStorage的使用: 清空localStorage 1localStorage.clear() 存储数据 12localStorage.setItem(&quot;name&quot;,&quot;Mark&quot;) localStorage.name = &quot;Mark&quot;; 读取数据 1234localStorage.getItem(&quot;Mark&quot;)//读取保存在localStorage对象里名为name的变量的值localStorage.name //&quot;Mark&quot;localStorage.valueOf()//读取存储在localStorage上的所有数据localStorage.key(0) // 读取第一条数据的变量名(键值) 删除某个变量 1localStorage.removeItem(&quot;name&quot;); //undefined 检查localStorage里是否保存某个变量 12localStorage.hasOwnProperty(&apos;name&apos;) // truelocalStorage.hasOwnProperty(&apos;sex&apos;) // false 将数组转为本地字符串 12345var arr = [&apos;aa&apos;,&apos;bb&apos;,&apos;cc&apos;]; // [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]localStorage.arr = arr //[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]localStorage.arr.toLocaleString(); // &quot;aa,bb,cc&quot; 将JSON存储到localStorage里 123456789101112131415161718192021222324var students = &#123; xiaomin: &#123; name: &quot;xiaoming&quot;, grade: 1 &#125;, teemo: &#123; name: &quot;teemo&quot;, grade: 3 &#125;&#125;students = JSON.stringify(students); //将JSON转为字符串存到变量里console.log(students);localStorage.setItem(&quot;students&quot;,students);//将变量存到localStorage里 var newStudents = localStorage.getItem(&quot;students&quot;);newStudents = JSON.parse(students); //转为JSONconsole.log(newStudents); // 打印出原先对象 0x03 SessionStorage&emsp;&emsp;sessionStorage 是HTML5新增的一个会话存储对象，用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。在JavaScript语言中可通过 window.sessionStorage 或 sessionStorage 调用此对象。 &emsp;&emsp;sessionStorage的使用： 存储数据 12sessionStorage.setItem(&apos;testKey&apos;,&apos;这是一个测试的value值&apos;);//采用setItem()方法存储sessionStorage[&apos;testKey&apos;] = &apos;这是一个测试的value值&apos;;//通过属性方式存储 读取数据 12sessionStorage.getItem(&apos;testKey&apos;); //通过getItem()方法取值、sessionStorage[&apos;testKey&apos;]; // 通过属性方式取值 存储Json对象 &emsp;&emsp;sessionStorage也可存储Json对象：存储时，通过JSON.stringify()将对象转换为文本格式；读取时，通过JSON.parse()将文本转换回对象。 123456789101112var userEntity = &#123; name: &apos;tom&apos;, age: 22&#125;; // 存储值：将对象转换为Json字符串sessionStorage.setItem(&apos;user&apos;, JSON.stringify(userEntity));// 取值时：把获取到的Json字符串转换回对象var userJsonStr = sessionStorage.getItem(&apos;user&apos;);userEntity = JSON.parse(userJsonStr);console.log(userEntity.name); // =&gt; tom 0x04 三者比较 特性 localstorage SessionStorage Cookie 存储空间 5M左右 5M左右 4k，不能超过20个 生命周期 永久 当前会话 在设置的过期时间之前一直有效 与服务器通信 仅在浏览器中保存，不参与和服务器的通话 仅在浏览器中保存，不参与和服务器的通话 携带在HTTP头中,使用过多会导致性能的问题 应用场景 常用于长期登录（判断用户是否已登录） 敏感账号的一次性登录 1.判断用户是否登陆过网站，以便下次登录时能够实现自动登录（记住密码）；2.保存上次登录的时间等信息；3.保存上次查看的页面；4.浏览计数 作用域 不同浏览器无法共享，相同浏览器的不同页面之间可以共享localStorage（页面属于相同域名和端口） 不同浏览器无法共享，不同页面或标签页间无法共享。（当一个标签页包含多个iframe标签且属于同源页面，可以共享） Cookie的作用域为当前设置的域名及其子域名 接口 可以接受原生接口，也可以封装来对Object和Array有更好支持 可以接受原生接口，也可以封装来对Object和Array有更好支持 原生的Cookie接口不友好，需要自己封装setCookie，getCookie &emsp;&emsp;这三者的共同点是：都是保存在浏览器端，且同源的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[create-react-app中使用react-router-dom实现路由跳转]]></title>
      <url>%2F2018%2F12%2F03%2Fcreate-react-app%E4%B8%AD%E4%BD%BF%E7%94%A8react-router-dom%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%2F</url>
      <content type="text"><![CDATA[0x00 写在前面&emsp;&emsp;说来很奇怪，之前用create-react-app写的web网页，结合ant desgin布局写的一个导航栏路由跳转。启动项目之后，首页有数据展示，点击导航栏可以跳转。但是！在整合了electron和react之后，启动项目之后首页空白，默认导航栏位置错误，要人为点击一下才有数据展示。这样用户体验真的真的很不友好。也是查了好久好久才解决了这个问题，于是决定写一篇博客，总结一下react-router-dom。 0x01 react-router-dom的安装与使用&emsp;&emsp;react-router-dom的使用有两种方式。 1. 使用npm1$ npm install --save react-router-dom js文件中1234567// using ES6 modulesimport &#123; BrowserRouter, Route, Link &#125; from &apos;react-router-dom&apos;//推荐使用 // using CommonJS modulesconst BrowserRouter = require(&apos;react-router-dom&apos;).BrowserRouterconst Route = require(&apos;react-router-dom&apos;).Routeconst Link = require(&apos;react-router-dom&apos;).Link 2. 使用unpkg1&lt;script src=&quot;https://unpkg.com/react-router-dom/umd/react-router-dom.min.js&quot;&gt;&lt;/script&gt; &emsp;&emsp;注意的是，这种方式还需要引入react的一些核心文件和依赖文件。不推荐使用这种方式。 0x02 react-router-dom与react-router的区别 react-router: 实现了路由的核心功能 react-router-dom: 基于react-router，加入了在浏览器运行环境下的一些功能，例如：Link组件，会渲染一个a标签，Link组件源码a标签行; BrowserRouter和HashRouter组件，前者使用pushState和popState事件构建路由，后者使用window.location.hash和hashchange事件构建路由。&emsp;&emsp;接下来将介绍react-router-dom的一些组件 0x03 react-router-dom的详细介绍1.HashRouter和BrowserRouter&emsp;&emsp;这两个API两个是路由的基本，需要将它们包裹在最外层，两者只需要选其一。 HashRouter：使用URL的哈希部分（即window.location.hash）的来保持UI与URL同步。注意：哈希历史记录不支持location.key或location.state。如果你使用过react-router2或3或者vue-router，你经常会发现，在浏览器打开页面，其url中会有个#，例如localhost:3000/#，HashRouter就会出现这种情况，它是通过hash值来对路由进行控制。如果使用HashRouter，路由就会默认有这个#。 123&lt;HashRouter&gt; &lt;Route path=&quot;/&quot; componet=&#123;Home&#125;&gt;&lt;/Route&gt;&lt;/HashRouter&gt; 很多情况下不需要这个#，这时就需要用到BrowserRouter。它的原理是使用HTML5历史记录API（pushState，replaceState和popstate事件）的来保持UI与URL的同步， 下面将主要结合它来讲解。如果文件放在服务器的二级目录下就可以使用它。 12345678&lt;BrowserRouter basename=&quot;app&quot; forceRefresh=true getUserConfirmation=window.confirm keyLength=9&gt; &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/BrowserRouter&gt; basename:string。所有位置的基本URL，如果应用程序是从服务器上的子目录提供的，则需要将其设置为子目录。 也就是说，上面例子中的Linkde解析后的href属性为 href=”#/app/about”。 getUserConfirmation：function。用来确认导航功能。默认使用window.confirm。 forceRefresh:bool。如果为true，则路由器将在页面导航中使用全页刷新。可以在不支持HTML5历史记录API的浏览器中使用此功能。 keyLength:number。location.key的长度，默认为6。 children:node。要呈现的单个子元素。 例如”http://localhost:3000/app/&quot;,当主页前面是有一级目录app时，同样要显示主页的内容。这时需要配合Link使用。建议使用BrowserRouter。 2. Route&emsp;&emsp;Route用于控制路径对应显示的组件。常用的有exact、path以及component属性。 exact用于严格匹配，控制匹配到/路径时不会再继续向下匹配； path标识指向的路由路径； component表示要跳转的路径对应的显示组件； &emsp;&emsp;Route会有三大props，分别是location、history、match； history &emsp;&emsp;history 指的是 history 包，它是 React Router 的两个主要依赖之一（除了 React 本身），并且提供了几种不同的实现方式，用于在各种环境中管理 JavaScript 中的会话历史。&emsp;&emsp;history分成以下三种 browser history - 针对 DOM 环境，用于支持 HTML5 history API 的浏览器 hash history - 针对 DOM 环境，用于传统的旧式（低版本） 浏览器 memory history - history 在内存上的实现，用于测试以及 React Native 等非 DOM 环境 &emsp;&emsp;history对象具有以下属性和方法： length - number 历史堆栈中的条目数 action - string 当前的导航操作（push、replace 或 pop） location - object 当前访问的位置信息，见下文 push(path, [state]) - function 将一个新条目推入到历史堆栈中 replace(path, [state]) - function 替换历史堆栈中的当前条目 go(n) - function 将历史堆栈中的指针移动 n 个条目 goBack() - function 返回到上一个页面，相当于 go(-1) goForward() - function 进入到下一个页面，相当于 go(1) block(prompt) - function 阻止导航（请参阅 history 文档） &emsp;&emsp;history 对象是可变的。因此建议从 渲染组件时接收的属性中直接访问 location，而不是通过 history.location 进行访问。这样可以保证 React 在生命周期中的钩子函数正常执行。 1234567componentWillReceiveProps(nextProps) &#123; // true console.log(nextProps.location !== this.props.location); // false，因为 history 是可变的。 console.log(nextProps.history.location !== this.props.history.location);&#125; location &emsp;&emsp;location 代表应用程序的位置。如当前的位置，将要去的位置，或是之前所在的位置。&emsp;&emsp;location具有以下的属性： pathname - string URL 路径 search - string URL 中的查询字符串 hash - string URL 中的 hash 片段 state - object 存储至 location 中的额外状态数据，仅在 browser history 和 memory history 中有效。&emsp;&emsp;Router 将在以下几个地方提供 location 对象： 在 Route component 中，以 this.props.location 方式获取 在 Route render 中，以 ({ location }) =&gt; () 方式获取 在 Route children 中，以 ({ location }) =&gt; () 方式获取 在 withRouter 中，以 this.props.location 方式获取 &emsp;&emsp;location 对象永远不会发生改变，因此可以在生命周期钩子函数中使用 location 对象来查看当前访问地址是否发生改变。12345componentWillReceiveProps(nextProps) &#123; if (nextProps.location !== this.props.location) &#123; // 已经跳转了！ &#125;&#125; match &emsp;&emsp;Match是在使用Router之后被放入props中的一个属性，在class创建的组件中我们需要通过this.props.match来获取match之中的信息。match中包含的信息如下。 params: object 路径参数，通过解析 URL 中的动态部分获得键值对 isExact: bool 为 true 时，整个 URL 都需要匹配 path: string 用来匹配的路径模式，用于创建嵌套的 Route url: string URL 匹配的部分，用于嵌套的 Link &emsp;&emsp;在获取id时经常使用match。 3. Link和NavLink&emsp;&emsp;两者都可以控制路由跳转，不同点是NavLink的api更多。 Link：主要api是to，to可以接受string或者一个object，来控制url，表示路由要跳转的路径。1234567&lt;Link to=&quot;/home&quot; /&gt;&lt;Link to=&#123;&#123; pathname: &apos;/home&apos;, search: &apos;?page=1&apos;, hash: &apos;#the-hash&apos;, state: &#123; fromDashboard: true &#125;&#125;&#125; /&gt; &emsp;&emsp;这时点击Link就会跳转到home页面。 NavLink：它可以为当前选中的路由设置类名、样式以及回调函数等。 12345678910&lt;BrowserRouter&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;NavLink exact activeClassName=&quot;selected&quot; to=&quot;/home/1&quot;&gt;首页&lt;/NavLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;Route path=&quot;/home/:1&quot; componet=&#123;Home&#125;&gt;&lt;/Route&gt;&lt;/BrowserRouter&gt; &emsp;&emsp;exact用于严格匹配，匹配到/则不会继续向下匹配；to则是控制跳转的路径，activeClassName是选中状态的类名，可以为其添加样式。我们通过在/home后面添加1来向路由中传递信息，这结合了上面Route中的/second/:id，线面的1234内容显示需要用到match。 4. Switch&emsp;&emsp;Switch常常会用来包裹Route，它里面不能放其他元素，表示一次只能显示一个路由。用于渲染与路径匹配的第一个子 或 。但与不同的是， 只会渲染一个路由。而定义一系列 时，所有被匹配到的 将都会在页面被渲染出来。12&lt;Route exact path=&quot;/&quot; component=&#123;Service&#125; /&gt;&lt;Route path=&quot;/homepage&quot; component=&#123;Homepage&#125; /&gt; &emsp;&emsp;像这种情况，exact匹配到’/‘就不会再向下匹配，当url为”http://localhost:3000/&quot;时,两个页面都会被匹配到；（匹配不到页面）Switch有两个属性 location: object。用于匹配子元素而不是当前历史位置（通常是当前的浏览器 URL）的 location 对象。 children: node。 的子元素应该是 或 。只有第一个匹配当前路径的组件会被渲染。当 中包含 时，可以使用任何 拥有的路径匹配属性：path、exact 和 strict。from 只是 path 的别名。 5. Redirect&emsp;&emsp;Redirect有四个属性 to:string。链接到的路径名或位置。 to:object。要链接的位置。 push:bool。当为true时，重定向会将新条目推入历史记录，而不是替换当前条目 from:string。要重定向的路径名。用于在内部渲染时匹配位置。 0x04 结合小例子的讲解&emsp;&emsp;在这个小例子中，被放在最外层；的子节点是，表示当前只会渲染一个路由，如果不使用的话，两个组件将会以同时渲染在一个页面上；再接下来是，exact表示精确匹配到’’，只要匹配到’/‘就不会再往下匹配了，这时候就会出现将homepage和device两个页面都匹配到，这种情况下，如果不加Switch，就会按照先后顺序将两个组件都显示到同一个页面上；在加上switch的情况下，也会因为匹配到两个路径中有’/‘的组件而显示空白，这个时候，就需要加上Redirect，只显示第一个被匹配到的路径对应组件的内容。123456789101112131415161718&lt;Menu.Item key=&quot;1&quot;&gt; &lt;Link to=&quot;/service&quot;&gt;设备&lt;/Link&gt;&lt;/Menu.Item&gt;&lt;Menu.Item key=&quot;2&quot;&gt; &lt;Link to=&quot;/homepage&quot;&gt;取证&lt;/Link&gt;&lt;/Menu.Item&gt;&lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Device&#125;&gt; &lt;/Route&gt; &lt;Route path=&quot;/homepage&quot; component=&#123;Homepage&#125; /&gt; &lt;Redirect to=&quot;/&quot; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用setTimeout实现for循环中的计时器]]></title>
      <url>%2F2018%2F09%2F01%2F%E7%94%A8setTimeout%E5%AE%9E%E7%8E%B0for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8%2F</url>
      <content type="text"><![CDATA[写在前面&emsp;&emsp;要实现的功能：在for循环中写一个计时器，先隔2000毫秒打印1，再隔2000毫秒打印2….依次每间隔2000毫秒打印出0到9. 00x1 基本思路&emsp;&emsp;要实现分别输出数组中的所有值，通过简单的for循环就能实现。要实现间隔一段时间输出，则使用setTimeout函数。12345678function test()&#123; for (var i = 0; i &lt; 10; i++) &#123; // setTimeout(function()&#123; console.log(i);//分别输出i的值 // &#125;,2000) &#125; &#125;;test(); &emsp;&emsp;可以在控制台看到紧跟着分别输出了小于10的i的值。但是加上setTimeout函数后，控制台的内容却都变成了10。&emsp;&emsp;解释造成这种差别的原因，我们要从JavaScript的执行机制开始说起。 00x2 js执行机制与作用域链&emsp;&emsp;首先，JavaScript是单线程环境，代码从上到下依次执行。这种执行方这也被称作是“同步执行”。（同一时间JavaScript只能执行一段代码，如果这段代码要执行很长时间，那么之后的代码只能尽情地等待它执行完才能有机会执行）。&emsp;&emsp;但JavaScript中引进了异步机制。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有主线程上的任务执行完了，才通知”任务队列”，任务队列中的任务才会进入主线程执行。 &emsp;&emsp;在上面的代码中，for循环是同步代码，setTimeout是异步代码。遇到这种既包含同步又包含异步的情况，JavaScript依旧按照从上到下的顺序执行同步代码，并将异步代码插入任务队列。setTimeout的第二个参数则是把执行代码（console.log(i)）添加到任务队列需等待的毫秒数，但等待的时间是相对主程序完毕的时间计算的，也就是说，在执行到setTimeout函数时会等待一段时间，再将当前任务插入任务队列。&emsp;&emsp;最后，当执行完同步代码，js引擎就会去执行任务队列中的异步代码。这时候任务队列中就会有十个console.log(i)。我们知道，在每次循环中将setTimeout里面的代码“console.log(i)”放入任务队列时，i的值都是不一样的。但JavaScript引擎开始执行任务队列中的代码时，会开始在当前的作用域中开始找变量i，但是当前作用域中并没有对变量i进行定义。这个时候就会在创造该函数的作用域中寻找i。创建该函数的作用域就是全局作用域，这个时候就找到了for循环中的变量i，这时的i是全局变量，并且值已经确定：10。十个console.log“共享”i的值。这就是作用域链的问题。&emsp;&emsp;为了解决以上两个问题，可以使用let或者闭包或者箭头函数。 00x3 解决方案一——闭包&emsp;&emsp;终于来到了本文中最重要的一部分。什么是闭包？！&emsp;&emsp;闭包是指有权访问另一个函数作用域中的变量的函数。或者说，将函数作为参数或者返回值。创建闭包的常见方式，就是在一个函数内部创建另一个函数。以下面的代码为例。1234567891011function test()&#123; for (var i = 0; i &lt; 10; i++) &#123; (function(j)&#123;//闭包 setTimeout(function()&#123; console.log(j);//分别输出i的值 &#125;,4000) &#125;)(i);//闭包 &#125;; &#125;;test(); &emsp;&emsp;代码中注释为“闭包”的两行代码就是一个典型的闭包。我们在函数内部创建了一个函数，并将变量i以函数参数形式传递给内层函数中变量j，j就是这个函数中的局部变量，每次i传入的值不同，局部变量j的值也不同。 00x4 解决方案二——let&emsp;&emsp;如下面的代码所示，使用let替换var，也能输出0-9的值。这是因为，当for循环中的i是通过var定义的变量时，作用域是一整个封闭函数，是全局作用域；当i是通过let定义的变量时，作用域在代码块中，叫做块级作用域，在for循环这个子块中。12345678function test()&#123; for (let i = 0; i &lt; 10; i++) &#123; setTimeout(function()&#123; console.log(i);//分别输出i的值 &#125;,2000) &#125;;&#125;;test(); 00x5 解决方案三——箭头函数&emsp;&emsp;如下面的代码所示，使用let替换var，也能输出0-9的值。这是因为，当for循环中的i是通过var定义的变量时，作用域是一整个封闭函数，是全局作用域；当i是通过let定义的变量时，作用域在代码块中，叫做块级作用域，在for循环这个子块中。12345678function test()&#123; for (let i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i);//分别输出i的值 &#125;,2000) &#125;;&#125;;test(); 00x5 间隔输出&emsp;&emsp;在实际查看时，控制台并不是一开始就输出i的值，但是也并没有按照预期每隔一段时间输出i的值，问题就出现setTimeout等待的时间上，每次都是2000ms。在任务队列里，setTimeout按照异步的顺序执行，按照放入任务队列的顺序依次开始执行，所以几乎同时打印出值。也就是说，在异步的情况下，执行任务队列里的代码(console.log(i))按照先后顺序执行，没有明显的时间差。可以利用传入的i的值来设置这种时间差。12345678910function test()&#123; for (var i = 0; i &lt; 10; i++) &#123; (function(j)&#123;//闭包 setTimeout(function()&#123; console.log(j);//分别输出i的值 &#125;,2000*j) &#125;)(i);//闭包 &#125;;&#125;;test(); &emsp;&emsp;这样等待的时间就会分别变成20001,20002,2000*3……且传入i的值就立即执行，所以每次打印都会有2000ms的时间差。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Electron与vue实践初体验]]></title>
      <url>%2F2018%2F05%2F24%2Felectron%E4%B8%8Evue%E5%AE%9E%E8%B7%B5%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[写在前面&emsp;&emsp;最近接触了electronjs，官方文档上描述介绍Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，用于构建桌面应用。在开始构建electron或vue之前，默认已经安装了nodejs和git。npm镜像资源索取代理地址在国外，安装速度很慢，这里使用了淘宝提供的镜像cnpm来进行安装。 &emsp;&emsp;使用下面的命令来安装cnpm。1npm install -g cnpm --registry=https://registry.npm.taobao.org//安装cnpm 00x1 构建electron 首先，打开命令行，使用cnpm安装electron。12cnpm install -g electron//在全局安装cnpm install --save-dev electron//在当前目录安装 &emsp;&emsp;这里使用了全局安装方式： 打开git，在github上下载electron-quick-start。1234git clone https://github.com/electron/electron-quick-startcd electron-quick-startcnpm install //安装各种依赖cnpm run start //打开桌面应用 &emsp;&emsp;可以看到一个桌面应用被打开。 00x2 在electron中引入vue 新建一个vue项目 12345cnpm install -g vue-cli//全局安装vue-cli脚手架vue init webpack my-vue(项目名字)//初始化一个项目cd my-vuecnpm install //安装各种依赖npm run dev //打开这个项目 vue打包&emsp;&emsp;打开vue项目中config文件夹下的index.js文件，确认其中的assetsPublicPath修改为相对路径 ./。注意是build配置下的assetsPublicPath。 &emsp;&emsp;运行npm run build对vue项目进行打包，在dist文件夹中生成打包文件。将dist文件夹中生成的static文件夹和index.html放入electron-quick-start下，替换掉electron-quick-start的index.html。1npm run build &emsp;&emsp;再次在electron-quick-start目录中运行npm run start 00x3 打包 在electron-quick-start下安装打包插件 1cnpm install -g electron-packager//采用全局安装 使用electron-packager来进行打包，可以直接使用打包命令 electron-packager &emsp;&emsp;这里的参数: location of project：项目所在路径 name of project：打包的项目名字 platform：确定了你要构建哪个平台的应用（Windows、Mac 还是 Linux） architecture：决定了使用 x86 还是 x64 还是两个架构都用 electron version：electron 的版本 optional options：可选选项 &emsp;&emsp;但是这个命令很长，每次都这样输入会比较麻烦； 可以在package.json下的script下这样写 1&quot;electron_build&quot;: &quot;electron-packager ./ --platform=win32 --arch=x64 --icon=./app/img/electron.ico --overwrite&quot; 打包 1npm run electron_build &emsp;&emsp;运行打包命令就会生成一个文件夹，在里面就能找到打包生成的.exe文件。双击就能运行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongoDB-数据聚合的三种方式]]></title>
      <url>%2F2018%2F03%2F03%2FmongoDB-%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[00x1 group&emsp;&emsp;使用group可以执行相对复杂的聚合，先选定分组所依据的键，而后mongoDB就会将集合依据选定键进行分组，然后对每一个分组内的文档进行聚合，以得到结果文档。（1）group结构 12345678db.test.group(&#123; key:&#123;field:true&#125; //key为分组依据，相当于aggregate中的$group initial:&#123;count:0&#125; //在分组前对变量初始化，这里声明的变量在下面回调函数中作为result的属性使用。 condition://过滤条件，相当于aggregate中的$match。 reduce:function ( curr, result ) &#123;&#125; //第一个参数为当前分组中此时迭代到的文档对象，第二个参数为当前分组 &quot;$keyf&quot;:function() &#123;return &#125; //定义分组函数 finalize:function(result)&#123;&#125; //这里的result为reduce的result，代表当前分组。此函数对完成当前分组后回调。&#125;) &emsp;&emsp;Group有传入的命令中共有六个参数，其中三个是JavaScript函数，因此每次查询到匹配的数据，都会被转换为对象传入函数。从运行效率上来说，Group比Aggregate差一大截。 （2）使用场景&emsp;&emsp;对返回数据最多只包含20000个元素，最多支持20000独立分组。 00x2 aggregate&emsp;&emsp;aggregate是mongoDB中经常提起的“管道”。主要用于处理数据（如求和，统计平均值等），并返回计算后的数据结构。&emsp;&emsp;aggreagte是一个数组，其中包含多个对象（命令），通过遍历Pipleline数组对collection中的数据进行操作。&emsp;&emsp;下面介绍一下aggregate的聚合管道比较常用的几种操作：（1）$project&emsp;&emsp;修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 123456db.testtest.aggregate(&#123; $project:&#123; &quot;_id&quot;:1, &quot;name&quot;:1 &#125;&#125;) （2）$match&emsp;&emsp;用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。12345db.testtest.aggregate(&#123; $match:&#123; &quot;count&quot;:&quot;3&quot;, &#125;&#125;) （3）$limit&emsp;&emsp;用来限制MongoDB聚合管道返回的文档数。123db.testtest.aggregate(&#123; $limit:5&#125;) （4）$skip&emsp;&emsp;在聚合管道中跳过指定数量的文档，并返回余下的文档。123db.testtest.aggregate(&#123; $skip:8&#125;) （5）$unwind&emsp;&emsp;将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。123db.testtest.aggregate(&#123; $unwind:&quot;$identlist&quot;&#125;) （6）$group&emsp;&emsp;将集合中的文档分组，可用于统计结果。123db.testtest.aggregate(&#123; $group:&#123;&quot;_id&quot;:&quot;$count&quot;&#125;&#125;) （7）$sort&emsp;&emsp;将输入文档排序后输出123db.testtest.aggregate(&#123; $sort:&#123;&quot;count&quot;:1&#125;&#125;) （8）使用场景&emsp;&emsp;应用于常用的聚合操作；对聚合响应性能有一定要求时（索引及组合优化）；管道操作在中完成，由于内存有大小限制，处理的数据集大小有限。 00x3 MapReduce（1）MapReduce结构&emsp;&emsp;mapreduce是mongoDB中提供的用于数据聚合的一种方式。通过对集合中的各个满足条件的文档进行预处理，整理出想要的数据然后统计得到最终的统计结果。&emsp;&emsp;mapreduce的结构如下：12345678910111213db.runCommand(&#123; mapreduce:&lt;collection&gt;, //需要进行处理的集合名 map:&lt;mapfunction&gt;, //映射函数（分组） reduce:&lt;reducefunction&gt;, //统计函数 [,query:&lt;query filter object&gt;] //，在发往map函数之前，对文档进行过滤 [,sort:&lt;sorts the input objects using this key.Useful for optimization,like sorting by the emit key for fewer reduces&gt;] //在发往map函数之前，对文档进行排序 [,limit:&lt;number of objects to return from collection&gt;] //限制发往map函数的文档数量 [,out:&lt;see output options below&gt;] //新建集合，用于存放统计结果 [,keeptemp:&lt;true|false&gt;] //是否保存统计结果为临时集合 [,finalize:&lt;finalizefunction&gt;] //最终处理函数，对reduce返回结果（存入out之前）进行最终处理 [,scope:&lt;object where fields go into javascript global scope&gt;] //向map、reduce、finalize导入外部变量 [,verbose:true] //详细的统计信息，用于调试&#125;); &emsp;&emsp;使用MapReduce主要需要实现两个函数：Map函数和Reduce函数。接下来详细介绍这两个函数。（2）Map函数&emsp;&emsp;可以将Map函数理解为分组，调用emit（key，values），遍历collection中所有的记录。其中，emit中的key为分组依据；values为分组后需要保留的数据，为1时则统计该分组的值的个数。&emsp;&emsp;key对应最后结果集中的_id。经过Map函数处理的集合，每条数据中只有”key”和”values”两个字段。 （3）Reduce函数&emsp;&emsp;Reduce为统计函数，接受Map函数处理后返回的key和values作为参数，将key-values变成key-value，也就是把values数组变成一个个单一的value。当key-values中的values数组过大时，会被再切分成很多个小的key-values，再对这些小的key-values分别执行Reduce，再将多个块的结果组合成一个新的数组，作为Reduce函数的第二个参数，继续Reduce操作。这个类似于多阶的归并排序。（4）out和keeptemp&emsp;&emsp;out:&emsp;&emsp;在文档输出时，output是可选的，一般结构为{ “out”: option }。&emsp;&emsp;option可以有以下几个选项。1234&#123; replace : &quot;collection name&quot; &#125; – mapReduce的输出结果会替换掉原来的collection，collection不存在则创建。&#123; merge : &quot;collection name&quot; &#125; – 将新老数据进行合并，新的替换旧的，没有的添加进去。&#123; reduce : &quot;collection name&quot; &#125; – 存在老数据时，在原来基础上加新数据(即 new value = old value + mapReduce value)。&#123; inline : 1 &#125; – 不会创建collection，结果保存在内存里，只限于结果小于16MB的情况。 &emsp;&emsp;通常结构为{“out”:”collection name”}，如果collection不存在，就新建一个集合。 &emsp;&emsp;keeptemp&emsp;&emsp;值只能为true或者false，表明输出到的collection是否是临时的，如果想在连接关闭后任然保留这个集合，则需要指定keeptemp的值为”true”。在使用output的情况下，不必指定keeptemp为true。 （5）使用场景&emsp;&emsp;聚合要求复杂；大型数据集 00x4 三者比较 &emsp; group aggregate MapReduce 是否使用JavaScript引擎 是，定制reduce函数 是，不能编写自定义函数 是，MapReduce函数是用JavaScript编写的 返回结果集保存位置 内联,结果必须符合BSON文档的限制(当前是16Mb) 内联，服务器支持的最大文档大小(16Mb)，超过时会报错 内联、新集合、合并、替换、减少 处理数据集大小 将不会分组到一个超过10,000个键的结果集 操作在内存中完成，有内存大小限制，处理数据集大小有限 大型数据集，超过20000的独立分组建议采用MapReduce 处理性能 低于aggregate 较高，管道可重复使用 低于aggregate 灵活度 低于MapReduce 低于MapRduce 较高，能使用JavaScript 00x5 从一个小例子具体分析&emsp; &emsp; 为公司的每个用户分配一张卡（有唯一的卡号”_id”）；持有该卡的用户可以使用这张卡在不同的超市消费，每个超市都有一个标识码，用”identlist”存放用户消费过的超市标识码；持有该卡的用户名字用”name”表示，默认在该公司中，每个人的姓名都是唯一的，与”_id”一一对应；”eventline”列举用户每次消费购买的物品；”timeline”记录每次消费的时间;”newtimeline”为用户最近一次消费的时间。&emsp; &emsp;示例数据如下：&emsp; &emsp;知道最近有几家超市做促销（数组A），要求（1）获取在A中任意一家或多家超市消费过的卡的持有者；（2）这些卡的最新消费时间；（3）这些卡的累积消费次数；（4）根据最新消费时间/累积消费次数对获取到的这些卡的数据进行排序；对排序后的数据进行分页。&emsp; &emsp;分析：要求中最难的是第一步：遍历数组A，将A中的每一条数据，作为分组依据（可能将原来的一条数据拆分成几条）；再对分组后的数据以”_id”进行聚合。（1）使用MapReduce实现以上要求。 1234567891011121314151617181920212223242526272829var map = function()&#123; emit(this.name,this.timeline); &#125;;var reduce = function(key,values)&#123; return Array.sum(values); &#125;;db.testtest.mapReduce( map, reduce, &#123; query:&#123;$where:function()&#123; var arr = new Array(&quot;Jk3Nx5-YUxBJZ-Zklt&quot;,&quot;LMuHW7-JtnwQC-OBIh&quot;); for(var index in arr)&#123; for(var current in this.identlist)&#123; if(this.identlist[current] == arr[index])&#123; return true; &#125; return false; &#125; &#125; &#125;&#125;, sort:&#123;&quot;count&quot;:1&#125;, finalize:function(key,value)&#123;return &#123;count:value.length,time:value[0]&#125;;&#125;, out:&quot;bbb_result&quot; &#125;)db.bbb_result.find().skip(1).limit(5) （2）使用aggregate123456789101112var arr = new Array(&quot;wdeVyU-YVutsF-CEza&quot;,&quot;Jk3Nx5-YUxBJZ-Zklt&quot;);db.getCollection(&apos;testtest&apos;).aggregate([ &#123;&apos;$unwind&apos;:&quot;$identlist&quot;&#125;, &#123;&quot;$match&quot;:&#123;&quot;identlist&quot;:&#123;&quot;$in&quot;:arr&#125;&#125;&#125;, &#123;$group:&#123;_id:&quot;$name&quot;,timeline:&#123;$addToSet:&quot;$timeline&quot;&#125;&#125;&#125;, &#123;&apos;$unwind&apos;:&quot;$timeline&quot;&#125;, &#123;&apos;$unwind&apos;:&quot;$timeline&quot;&#125;, &#123;$group:&#123;_id:&quot;$_id&quot;,time:&#123;$first:&quot;$timeline&quot;&#125;,count:&#123;&quot;$sum&quot;:1&#125;&#125;&#125;, &#123;$sort:&#123;&quot;count&quot;:-1&#125;&#125;, &#123;$skip:0&#125;, &#123;$limit:5&#125;]) &emsp; &emsp;以上两个小例子经测试后均能实现要求，这里不做详细解释，需要的请自取~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Vue项目中使用Mock.js构造模拟数据]]></title>
      <url>%2F2018%2F03%2F03%2F%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Mock-js%E6%9E%84%E9%80%A0%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[00x1 mockjs简介&emsp;&emsp;mock.js是一款开发前端虚拟接口的插件，主要有两个功能 生成随机数据 拦截Ajax请求00x2 在vue-cli项目中安装配置mockjs &emsp;&emsp;首先确保安装并成功引入axios；&emsp;&emsp;然后安装mockjs npm install mockjs –save-dev；&emsp;&emsp;在main.js文件中引入mockjs并配置axios跨域信息：12345678910111213141516171819202122232425262728293031require(&apos;./mock.js&apos;) //配置axios跨域请求头部axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;//配置axios请求拦截器axios.interceptors.request.use(function(config) &#123; return config; &#125;, function(error) &#123; return Promise.reject(error); &#125;)//配置axios响应拦截器axios.interceptors.response.use(function(response) &#123; return response;&#125;, function(error) &#123; return Promise.reject(error);&#125;)//封装axios的post请求export function fetch(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, params).then(response =&gt; &#123; resolve(response.data); &#125;).catch((error) =&gt; &#123; reject(error); &#125;) &#125;)&#125;//封装接口信息export default &#123; http(url, params) &#123; return fetch(url, params); &#125;&#125; 00x3 Mock.js语法&emsp;&emsp;mock.js语法分为两种，数据模板定义和数据占位符定义 数据模板定义基本结构：属性名|生成规则:属性值1234567（1）&apos;name|min-max&apos;: value（2）&apos;name|count&apos;: value（3）&apos;name|min-max.dmin-dmax&apos;: value（4）&apos;name|min-max.dcount&apos;: value（5）&apos;name|count.dmin-dmax&apos;: value（6）&apos;name|count.dcount&apos;: value（7）&apos;name|+step&apos;: value (1)属性值是字符串String123451. name|min-max: string通过重复string生成一个字符串，重复次数大于等于min，小于等于max。这里的重复是指对初始化string的重复次数。2. name|count: string通过重复string生成一个字符串，重复次数等于count。 (2)属性值是数字Number123456781. name|+1 : number属性值自动加1， 初始值为number2. name|min-max: number生成一个大于等于min，小于等于max的整数。3. name|min-max.dmin-dmax: number生成一个浮点数，整数部分大于等于min，小于等于max，小数部分保留dmin到dmax位。 （3）属性值是布尔类型Boolean123451. name|1: boolean随机生成一个布尔值，值为true的概率为1/2， 值为false的概率为1/2。2. name|min-max: value随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。 （4）属性值是对象Object123451. name|count: object从属性值object中随机选取count个属性2. name|min-max: object从属性值object中随机选取min到max个属性 (5) 属性值是数组Array12345678910111. name|1: array从属性值array中随机选取一个元素，作为最终值2. name|+1: array从属性值array中顺序选取一个元素，作为最终值3. name|min-max: array通过重复属性值array生成一个新数组，重复次数大于等于min，小于等于max。4. name|count: array通过重复属性值array生成一个新数组，重复次数为count。 (6) 属性值是函数Function123&apos;name&apos;: function执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 &apos;name&apos; 所在的对象。 (7) 属性值是正则表达式RegExp121. name: regexp根据正则表达式regexp反向生成可以匹配他的字符串。用于生成自定义格式的字符串。 数据占位符定义基本结构：属性名：占位符1&apos;name|&apos;:&apos;@占位符()&apos; &emsp;&emsp;占位符也可以引用数据模板中的属性；占位符会有限引用数据模板中的属性；占位符支持相对路径和绝对路径。 00x4 Mock.mock() Mock.mock(rurl?, rtype?, template|function(options)) 根据数据模板生成模拟数据 Mock.mock(template) 根据数据模板生成模拟数据。 Mock.mock(rurl, template) 记录数据模板，当拦截到匹配rurl的ajax请求时，根据数据模板生成模拟数据，并作为响应数据返回。 Mock.mock(rurl, function(options)) 记录用于生成响应数据的函数。当拦截到匹配rurl的ajax请求时，函数function执行，并把执行结果作为响应数据返回。 Mock.mock(rurl, rtype, template) 记录数据模板，当拦截到匹配rurl和rtype的ajax请求时，将根据数据模板生成模拟数据，并作为响应数据返回。 Mock.mock(rurl, rtype, function(options)) 记录用于生成响应数据的函数。当拦截到匹配rurl和rtype的ajax请求时，函数function(options)将被执行，并把执行结果作为响应数据返回。 rurl 标识需要拦截的url，可以是url字符串或者url正则： 1/\/domain\/list\.json/、&apos;/domian/list.json&apos;。 rtype 可选，标识需要拦截的ajax请求类型。例如GET, POST, PUT, DELETE等。 template 可选，标识数据模板，可以是对象或字符串。 function(options) 可选，表示用于生成响应数据的函数。 options 指向本次请求的ajax选项集，含有url， type和body三个属性。 00x5 构造模拟数据 &emsp;&emsp;新建一个mock.js文件，在mock.js文件中引入mockjs1const Mock = require(&apos;mockjs&apos;); &emsp;&emsp;根据mock.js语法格式构造模拟数据12345678910111213141516171819202122232425262728export default Mock.mock(&apos;http://test.com&apos;, &#123; &apos;cur_ip&apos;:&#123; &apos;data&apos;:&apos;@date&apos;, &apos;ip&apos;:&apos;@ip&apos;, &apos;number|1-100&apos;:10000, &apos;rank|1-100&apos;:20, &apos;info&apos;:&apos;@title(3)&apos;, &#125;, &apos;cur_whois&apos;:[&#123; &apos;alexa|1-300&apos;:100, &quot;cdate&quot;:&apos;@datetime&apos;, &quot;edate&quot;:&apos;@datetime&apos;, &quot;name_server&quot;:&apos;@domain&apos;, &quot;registrant_address&quot;:&apos;@county(true)&apos;, &quot;registrant_company&quot;:&apos;@ctitle(3, 5)&apos;, &quot;registrant_email&quot;:&apos;@email&apos;, &quot;registrant_name&quot;:&apos;@name(true)&apos;, &quot;registrant_phone&quot;:/^1[0-9]&#123;10&#125;$/, &quot;registrar_name&quot;:&apos;@name(true)&apos;, &quot;udate&quot;:&apos;@datetime&apos;, &#125;], &apos;history_ip|20&apos;:[&#123; &quot;date&quot;:&apos;@datetime&apos;, &quot;ip&quot;:&apos;@ip&apos;, &quot;info&quot;:&apos;@title(3)&apos;, &#125;],&#125;） &emsp;&emsp;mock.js也支持模拟ajax请求响应时间，自定义的响应时间可以是绝对值，也可以是区间。123456Mock.setup(&#123; timeout: 40000//40秒后再响应&#125;)Mock.setup(&#123; timeout: &apos;10000-40000&apos;//在10秒和40秒之间响应&#125;) 00x6 请求获取数据&emsp;&emsp;在需要数据的页面中引入构造的mock的api1import mock from &apos;../main.js&apos; &emsp;&emsp;请求获取数据123mock.http(&apos;http://test.com&apos;, &apos;type=top&amp;key=123456&apos;).then(res =&gt; &#123; console.log(res);&#125;); &emsp;&emsp;完成到这一步后，打开项目就可以看到已经生成的模拟数据，亲测可用。如果只是想了解mockjs语法，可以在打开官网，直接使用示例语法在浏览器控制台上进行测试。 参考：http://mockjs.com/examples.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongoDB安装与配置]]></title>
      <url>%2F2017%2F07%2F26%2FmongoDB%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[00x1 mongodb的安装与配置 (1)在mongodb的官网https://www.mongodb.com/download-center#community 下载安装文件。 进入官网，直接点击donwnload即可。 (2)双击.msi文件安装 (3)创建数据目录 进入mongodb的安装包，创建数据目录 D:\software\mongodb\mkdir data D:\software\mongodb\cd data D:\software\mongodb\data\cd db D:\software\mongodb\data\db\ (4)命令行下运行mongodb服务器 进入mongodb安装目录下的bin文件夹 D:\software\mongodb\bin\mongod.exe --dbpath D:\software\mongodb\data\db 出现下面的内容就表示正确运行了。 当然这一步也有可能出现问题，比如我就遇到了“mongod不是内部或外部命令,也不是可运行的程序”这个问题。 最开始我在环境变量中加入了bin文件夹的路径，但是问题没有解决。 解决方法：直接在bin文件夹中双击打开mongod.exe文件。同样会出现以上的内容。 然后在浏览器中打开http://localhost:27017进行测试。出现下面的内容表示mongodb的服务器正确运行了。 (5)将mongodb安装为windows服务（命令行要有管理员权限） D:\software\mongodb\bin\mongod --dbpath D:\software\mongodb\data --install 但是出现了下面的提示，表明安装失败。 按照提示，需要指定log目录。因此重新切换到bin目录下，新建logs文件。并在logs文件夹下新建mongodb.log文件。 创建日志目录： D:\software\mongodb\mkdir logs D:\software\mongodb\cd logs D:\software\mongodb\logs 然后重新进入bin文件夹，输入命令： D:\software\mongodb\bin\mongod --dbpath D:\software\mongodb\data --logpath=D:\software\mongodb\logs\mongodb.log --logappend. 没有出现错误提示。 也能够正常启动：6.MongoDB后台管理shell（命令行要有管理员权限） 打开 MongoDB shell，失败。 连接失败，net start MongoDB服务，服务不能正常打开，mongo的服务没有被正确创建。 使用sc命令创建mongodb服务，需要注意的是，这一步的cmd必须要以管理员权限打开。 D:\software\mongodb\bin\sc create MongDB binpath=&quot;D:\software\mongo\bin\mongod.exe --service --dbpath D:\software\mongodb\data --logpath=D:\software\mongodb\logs\mongodb.log --logappend 服务创建成功 net start MongoDB 服务也可以正常启动 MongoDB Shell是MongoDB自带的交互式Javascript shell,用来对MongoDB进行操作和管理的交互式环境。可以运行一些简单的算术运算 (7)设置环境变量 进入电脑上的环境变量，在系统变量下的path中加入mongodb目录下的bin文件的路径。 这样命令行就可以在任何位置使用mongodb命令，不需要每次使用mongo和mongod命令的时候都进入 bin文件夹下。 00x2 配置过程中一些命令的总结 在配置过程中，出现问题最多的是将mongodb安装为windows服务，和mongodb后台管理shell这两步骤。在解决这两步的问题时，尝试了不同的命令，在这里做一个总结。 (1)进入bin文件夹下 mongod.exe --bind_ip yourIPadress --logpath &quot;C:\data\dbConf\mongodb.log&quot; --logappend --dbpath &quot;C:\data\db&quot; --port yourPortNumber --serviceName &quot;YourServiceName&quot; --serviceDisplayName &quot;YourServiceName&quot; --install (2)打开具有管理员身份的cmd 如果已经有某个服务名了，比如MongoDB，那么先把这个服务删了， sc delete MongoDB 然后进入mongodb安装目录下的bin文件 mongod --logpath d:\data\log\MongoDB.log --logappend --dbpath d:\data\db --serviceName MongoDB --install (3)同样是进入mongodb安装目录下的bin文件下 mongod --logpath &quot;D:\software\mongodb\data\mongodb.log&quot; --logappend --dbpath &quot;D:\software\mongodb\data&quot; --serviceName &quot;MongoDB&quot; --serviceDisplayName &quot;MongoDB&quot; --install 在解决这部分问题之后，觉得使用这些命令没有成功的原因可能是命令行没有获取管理员权限，还有就是mongdb 的服务没有被正确创建。最正确的创建mongodb服务的方法是使用sc命令进行创建。 D:\software\mongodb\bin\sc create MongDB binpath=&quot;D:\software\mongo\bin\mongod.exe --service --dbpath D:\software\mongodb\data --logpath=D:\software\mongodb\logs\mongodb.log --logappend]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[表单提交类型与ajax]]></title>
      <url>%2F2017%2F04%2F23%2F%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E7%B1%BB%E5%9E%8B%E4%B8%8Eajax%2F</url>
      <content type="text"><![CDATA[00x1 问题描述 在写蜜罐时，遇到了form表单提交的一个问题。使用ajax方式异步提交表单，点击提交按钮后，1.提交页面刷新。ajax使用的是POST方式提交，但是在地址栏出现了GET方式提交才会出现的地址类型。2.数据库中数据成功入库，但是回调函数不显示。 00x2 问题分析及解决数据成功入库，说明ajax提交数据是成功的。而在地址栏中，又出现了GET方式提交才会出现的地址类型，说明表单中的数据应该是被提交了两次，第一次以POST方式（ajax中type设置成“POST”）提交，然后再以GET方式提交。 通过查找资料发现，代码中将button的type设置成了“submit”，将提交按钮的type属性修改成“button”，问题就会解决。submit默认为以GET方式进行表单提交（form）。button则响应用户自定义的事件，如果不指定onclick等事件处理函数，它不做任何事情。以ajax方式提交时，jQuery给提交按钮绑定了click事件，ajax中设定了以POST方式提交。而在button中，type被设置成submit，默认以GET方式提交。就引出了关于click和submit执行先后顺序的问题。 00x3 click和submit执行的先后顺序 点击提交按钮时，是先触发click事件，然后再触发submit事件。这里主要说的是click的处理后续和submit的处理后续：click-&gt;click响应事件-&gt;submit响应事件-&gt;submit。click的处理事件完成后，然后轮到submit事件的处理以及处理后的submit。到这一步，感觉问题就快解决了。但是如果ajax提交表单成功之后，再submit以get方式提交的话。过程中就肯定能看到数据入库后返回的回调函数。就说明，ajax提交并没有完全执行，应该是在向后台提交数据之后和在success返回回调信息之间出现了阻塞。 00x4 同步和异步的区别 在JS中负责解释和执行JavaScript代码的线程只有一个。 这里我们叫做主线程。实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外。我们把它叫做工作线程。主线程发起一个异步请求（提交form表单），相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务（提交form表单到数据库）；工作线程完成工作后，通知主线程（数据成功入库，返回执行结果，并将其放入消息队列）；主线程收到通知后（主线程通过事件循环从消息队列里取消息），执行一定的动作(调用回调函数来处理返回结果) ；触发submit响应（返回值不为FALSE），执行表单的submit事件。又因为给了action的地址，所以会出现跳转。并且在跳转地址中出现GET方式的提交。 在同步情况下，主线程发起一个同步请求（提交form表单），相应的工作线程接收请求并立即开始执行同步任务（提交form表单到数据库）；主线程则一直等待，直到工作线程完工作通知主线程（数据成功入库，返回执行结果，回调函数处理返回结果）。因为返回结果不为FALSE，所以在出现提示之后，出现跳转。 00x5 submit阻止表单提交 参考：ajax同步和异步的区别：http://www.open-open.com/lib/view/open1453079994386.html]]></content>
    </entry>

    
  
  
</search>
