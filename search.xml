<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[在Vue项目中使用Mock.js构造模拟数据]]></title>
      <url>%2F2018%2F03%2F03%2F%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Mock-js%E6%9E%84%E9%80%A0%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[00x1 mockjs简介&emsp;mock.js是一款开发前端虚拟接口的插件，主要有两个功能 生成随机数据 拦截Ajax请求00x2 在vue-cli项目中安装配置mockjs&emsp;首先确保安装并成功引入axios；&emsp;然后安装mockjs npm install mockjs –save-dev；&emsp;在main.js文件中引入mockjs并配置axios跨域信息： 12345678910111213141516171819202122232425262728293031require(&apos;./mock.js&apos;) //配置axios跨域请求头部axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;//配置axios请求拦截器axios.interceptors.request.use(function(config) &#123; return config; &#125;, function(error) &#123; return Promise.reject(error); &#125;)//配置axios响应拦截器axios.interceptors.response.use(function(response) &#123; return response;&#125;, function(error) &#123; return Promise.reject(error);&#125;)//封装axios的post请求export function fetch(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, params).then(response =&gt; &#123; resolve(response.data); &#125;).catch((error) =&gt; &#123; reject(error); &#125;) &#125;)&#125;//封装接口信息export default &#123; http(url, params) &#123; return fetch(url, params); &#125;&#125; 00x3 Mock.js语法&emsp;mock.js语法分为两种，数据模板定义和数据占位符定义 数据模板定义基本结构：属性名|生成规则:属性值1234567（1）&apos;name|min-max&apos;: value（2）&apos;name|count&apos;: value（3）&apos;name|min-max.dmin-dmax&apos;: value（4）&apos;name|min-max.dcount&apos;: value（5）&apos;name|count.dmin-dmax&apos;: value（6）&apos;name|count.dcount&apos;: value（7）&apos;name|+step&apos;: value (1)属性值是字符串String123451. name|min-max: string通过重复string生成一个字符串，重复次数大于等于min，小于等于max。这里的重复是指对初始化string的重复次数。2. name|count: string通过重复string生成一个字符串，重复次数等于count。 (2)属性值是数字Number123456781. name|+1 : number属性值自动加1， 初始值为number2. name|min-max: number生成一个大于等于min，小于等于max的整数。3. name|min-max.dmin-dmax: number生成一个浮点数，整数部分大于等于min，小于等于max，小数部分保留dmin到dmax位。 （3）属性值是布尔类型Boolean123451. name|1: boolean随机生成一个布尔值，值为true的概率为1/2， 值为false的概率为1/2。2. name|min-max: value随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。 （4）属性值是对象Object123451. name|count: object从属性值object中随机选取count个属性2. name|min-max: object从属性值object中随机选取min到max个属性 (5) 属性值是数组Array12345678910111. name|1: array从属性值array中随机选取一个元素，作为最终值2. name|+1: array从属性值array中顺序选取一个元素，作为最终值3. name|min-max: array通过重复属性值array生成一个新数组，重复次数大于等于min，小于等于max。4. name|count: array通过重复属性值array生成一个新数组，重复次数为count。 (6) 属性值是函数Function123&apos;name&apos;: function执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 &apos;name&apos; 所在的对象。 (7) 属性值是正则表达式RegExp121. name: regexp根据正则表达式regexp反向生成可以匹配他的字符串。用于生成自定义格式的字符串。 数据占位符定义基本结构：属性名：占位符1&apos;name|&apos;:&apos;@占位符()&apos; &emsp;占位符也可以引用数据模板中的属性；占位符会有限引用数据模板中的属性；占位符支持相对路径和绝对路径。 00x4 Mock.mock() Mock.mock(rurl?, rtype?, template|function(options)) 根据数据模板生成模拟数据 Mock.mock(template) 根据数据模板生成模拟数据。 Mock.mock(rurl, template) 记录数据模板，当拦截到匹配rurl的ajax请求时，根据数据模板生成模拟数据，并作为响应数据返回。 Mock.mock(rurl, function(options)) 记录用于生成响应数据的函数。当拦截到匹配rurl的ajax请求时，函数function执行，并把执行结果作为响应数据返回。 Mock.mock(rurl, rtype, template) 记录数据模板，当拦截到匹配rurl和rtype的ajax请求时，将根据数据模板生成模拟数据，并作为响应数据返回。 Mock.mock(rurl, rtype, function(options)) 记录用于生成响应数据的函数。当拦截到匹配rurl和rtype的ajax请求时，函数function(options)将被执行，并把执行结果作为响应数据返回。 rurl 标识需要拦截的url，可以是url字符串或者url正则： 1/\/domain\/list\.json/、&apos;/domian/list.json&apos;。 rtype 可选，标识需要拦截的ajax请求类型。例如GET, POST, PUT, DELETE等。 template 可选，标识数据模板，可以是对象或字符串。 function(options) 可选，表示用于生成响应数据的函数。 options 指向本次请求的ajax选项集，含有url， type和body三个属性。 00x5 构造模拟数据&emsp;新建一个mock.js文件，在mock.js文件中引入mockjs 1const Mock = require(&apos;mockjs&apos;); &emsp;根据mock.js语法格式构造模拟数据12345678910111213141516171819202122232425262728export default Mock.mock(&apos;http://test.com&apos;, &#123; &apos;cur_ip&apos;:&#123; &apos;data&apos;:&apos;@date&apos;, &apos;ip&apos;:&apos;@ip&apos;, &apos;number|1-100&apos;:10000, &apos;rank|1-100&apos;:20, &apos;info&apos;:&apos;@title(3)&apos;, &#125;, &apos;cur_whois&apos;:[&#123; &apos;alexa|1-300&apos;:100, &quot;cdate&quot;:&apos;@datetime&apos;, &quot;edate&quot;:&apos;@datetime&apos;, &quot;name_server&quot;:&apos;@domain&apos;, &quot;registrant_address&quot;:&apos;@county(true)&apos;, &quot;registrant_company&quot;:&apos;@ctitle(3, 5)&apos;, &quot;registrant_email&quot;:&apos;@email&apos;, &quot;registrant_name&quot;:&apos;@name(true)&apos;, &quot;registrant_phone&quot;:/^1[0-9]&#123;10&#125;$/, &quot;registrar_name&quot;:&apos;@name(true)&apos;, &quot;udate&quot;:&apos;@datetime&apos;, &#125;], &apos;history_ip|20&apos;:[&#123; &quot;date&quot;:&apos;@datetime&apos;, &quot;ip&quot;:&apos;@ip&apos;, &quot;info&quot;:&apos;@title(3)&apos;, &#125;],&#125;） &emsp;mock.js也支持模拟ajax请求响应时间，自定义的响应时间可以是绝对值，也可以是区间。123456Mock.setup(&#123; timeout: 40000//40秒后再响应&#125;)Mock.setup(&#123; timeout: &apos;10000-40000&apos;//在10秒和40秒之间响应&#125;) 00x6 请求获取数据&emsp;在需要数据的页面中引入构造的mock的api1import mock from &apos;../main.js&apos; &emsp;请求获取数据123mock.http(&apos;http://test.com&apos;, &apos;type=top&amp;key=123456&apos;).then(res =&gt; &#123; console.log(res);&#125;); &emsp;完成到这一步后，打开项目就可以看到已经生成的模拟数据，亲测可用。如果只是想了解mockjs语法，可以在打开官网，直接使用示例语法在浏览器控制台上进行测试。 参考：http://mockjs.com/examples.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongoDB安装与配置]]></title>
      <url>%2F2017%2F07%2F26%2FmongoDB%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[00x1 mongodb的安装与配置 (1)在mongodb的官网https://www.mongodb.com/download-center#community 下载安装文件。 进入官网，直接点击donwnload即可。(2)双击.msi文件安装 (3)创建数据目录 进入mongodb的安装包，创建数据目录 D:\software\mongodb\mkdir data D:\software\mongodb\cd data D:\software\mongodb\data\cd db D:\software\mongodb\data\db\ (4)命令行下运行mongodb服务器 进入mongodb安装目录下的bin文件夹 D:\software\mongodb\bin\mongod.exe --dbpath D:\software\mongodb\data\db 出现下面的内容就表示正确运行了。 当然这一步也有可能出现问题，比如我就遇到了“mongod不是内部或外部命令,也不是可运行的程序”这个问题。 最开始我在环境变量中加入了bin文件夹的路径，但是问题没有解决。 解决方法：直接在bin文件夹中双击打开mongod.exe文件。同样会出现以上的内容。 然后在浏览器中打开http://localhost:27017进行测试。出现下面的内容表示mongodb的服务器正确运行了。 (5)将mongodb安装为windows服务（命令行要有管理员权限） D:\software\mongodb\bin\mongod --dbpath D:\software\mongodb\data --install 但是出现了下面的提示，表明安装失败。 按照提示，需要指定log目录。因此重新切换到bin目录下，新建logs文件。并在logs文件夹下新建mongodb.log文件。 创建日志目录： D:\software\mongodb\mkdir logs D:\software\mongodb\cd logs D:\software\mongodb\logs 然后重新进入bin文件夹，输入命令： D:\software\mongodb\bin\mongod --dbpath D:\software\mongodb\data --logpath=D:\software\mongodb\logs\mongodb.log --logappend. 没有出现错误提示。 也能够正常启动：6.MongoDB后台管理shell（命令行要有管理员权限） 打开 MongoDB shell，失败。 连接失败，net start MongoDB服务，服务不能正常打开，mongo的服务没有被正确创建。 使用sc命令创建mongodb服务，需要注意的是，这一步的cmd必须要以管理员权限打开。 D:\software\mongodb\bin\sc create MongDB binpath=&quot;D:\software\mongo\bin\mongod.exe --service --dbpath D:\software\mongodb\data --logpath=D:\software\mongodb\logs\mongodb.log --logappend 服务创建成功 net start MongoDB 服务也可以正常启动 MongoDB Shell是MongoDB自带的交互式Javascript shell,用来对MongoDB进行操作和管理的交互式环境。可以运行一些简单的算术运算 (7)设置环境变量 进入电脑上的环境变量，在系统变量下的path中加入mongodb目录下的bin文件的路径。 这样命令行就可以在任何位置使用mongodb命令，不需要每次使用mongo和mongod命令的时候都进入 bin文件夹下。 00x2 配置过程中一些命令的总结 在配置过程中，出现问题最多的是将mongodb安装为windows服务，和mongodb后台管理shell这两步骤。在解决这两步的问题时，尝试了不同的命令，在这里做一个总结。 (1)进入bin文件夹下 mongod.exe --bind_ip yourIPadress --logpath &quot;C:\data\dbConf\mongodb.log&quot; --logappend --dbpath &quot;C:\data\db&quot; --port yourPortNumber --serviceName &quot;YourServiceName&quot; --serviceDisplayName &quot;YourServiceName&quot; --install (2)打开具有管理员身份的cmd 如果已经有某个服务名了，比如MongoDB，那么先把这个服务删了， sc delete MongoDB 然后进入mongodb安装目录下的bin文件 mongod --logpath d:\data\log\MongoDB.log --logappend --dbpath d:\data\db --serviceName MongoDB --install (3)同样是进入mongodb安装目录下的bin文件下 mongod --logpath &quot;D:\software\mongodb\data\mongodb.log&quot; --logappend --dbpath &quot;D:\software\mongodb\data&quot; --serviceName &quot;MongoDB&quot; --serviceDisplayName &quot;MongoDB&quot; --install 在解决这部分问题之后，觉得使用这些命令没有成功的原因可能是命令行没有获取管理员权限，还有就是mongdb 的服务没有被正确创建。最正确的创建mongodb服务的方法是使用sc命令进行创建。 D:\software\mongodb\bin\sc create MongDB binpath=&quot;D:\software\mongo\bin\mongod.exe --service --dbpath D:\software\mongodb\data --logpath=D:\software\mongodb\logs\mongodb.log --logappend]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[表单提交类型与ajax]]></title>
      <url>%2F2017%2F04%2F23%2F%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E7%B1%BB%E5%9E%8B%E4%B8%8Eajax%2F</url>
      <content type="text"><![CDATA[00x1 问题描述 在写蜜罐时，遇到了form表单提交的一个问题。使用ajax方式异步提交表单，点击提交按钮后，1.提交页面刷新。ajax使用的是POST方式提交，但是在地址栏出现了GET方式提交才会出现的地址类型。2.数据库中数据成功入库，但是回调函数不显示。 00x2 问题分析及解决数据成功入库，说明ajax提交数据是成功的。而在地址栏中，又出现了GET方式提交才会出现的地址类型，说明表单中的数据应该是被提交了两次，第一次以POST方式（ajax中type设置成“POST”）提交，然后再以GET方式提交。 通过查找资料发现，代码中将button的type设置成了“submit”，将提交按钮的type属性修改成“button”，问题就会解决。submit默认为以GET方式进行表单提交（form）。button则响应用户自定义的事件，如果不指定onclick等事件处理函数，它不做任何事情。以ajax方式提交时，jQuery给提交按钮绑定了click事件，ajax中设定了以POST方式提交。而在button中，type被设置成submit，默认以GET方式提交。就引出了关于click和submit执行先后顺序的问题。 00x3 click和submit执行的先后顺序 点击提交按钮时，是先触发click事件，然后再触发submit事件。这里主要说的是click的处理后续和submit的处理后续：click-&gt;click响应事件-&gt;submit响应事件-&gt;submit。click的处理事件完成后，然后轮到submit事件的处理以及处理后的submit。到这一步，感觉问题就快解决了。但是如果ajax提交表单成功之后，再submit以get方式提交的话。过程中就肯定能看到数据入库后返回的回调函数。就说明，ajax提交并没有完全执行，应该是在向后台提交数据之后和在success返回回调信息之间出现了阻塞。 00x4 同步和异步的区别 在JS中负责解释和执行JavaScript代码的线程只有一个。 这里我们叫做主线程。实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外。我们把它叫做工作线程。主线程发起一个异步请求（提交form表单），相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务（提交form表单到数据库）；工作线程完成工作后，通知主线程（数据成功入库，返回执行结果，并将其放入消息队列）；主线程收到通知后（主线程通过事件循环从消息队列里取消息），执行一定的动作(调用回调函数来处理返回结果) ；触发submit响应（返回值不为FALSE），执行表单的submit事件。又因为给了action的地址，所以会出现跳转。并且在跳转地址中出现GET方式的提交。 在同步情况下，主线程发起一个同步请求（提交form表单），相应的工作线程接收请求并立即开始执行同步任务（提交form表单到数据库）；主线程则一直等待，直到工作线程完工作通知主线程（数据成功入库，返回执行结果，回调函数处理返回结果）。因为返回结果不为FALSE，所以在出现提示之后，出现跳转。 00x5 submit阻止表单提交 参考：ajax同步和异步的区别：http://www.open-open.com/lib/view/open1453079994386.html]]></content>
    </entry>

    
  
  
</search>
