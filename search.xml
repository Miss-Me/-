<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[react+electron+ant-design+sqlite3实现一个桌面应用]]></title>
      <url>%2F2018%2F12%2F04%2Freact-electron-ant-design-sqlite3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[0x00 写在前面&emsp;&emsp;最近帮隔壁实验室写个简单的展示页面，想着自己学了一下nodejs与react，刚好可以用来练练手。于是使用sqlite3数据库，用nodejs来写后端，react写前端的前后端分离方法，完成了一个小demo。这时候又要求用electron改成桌面版的应用，这简单啊，把react打包出来的index.html放到electron下做入口文件不就OK了。但是又涉及到跟对方的Java环境下的jar包通信的问题，对方的思路是通过前端点击按钮在数据库里存入一个字段，jar包所在环境通过不断轮询数据库去获取该字段确定是否启动手机应用拖数据库。前端在点击按钮后不断轮询数据库，看需要的数据是否更新，有数据更新就取回数据，并在前端展示。对于这个方案，我是拒绝的。回来跟师兄讨论了一下，确定了下几种方案。 nodejs写后端，react写前端。前端请求后端，由nodejs命令行启动jar。打包react页面放到electron下作为入口文件。 nodejs写后端，react写前端。把react页面打包近electron下作为入口文件，由于electron是基于nodejs的，所以在electron里使用socket实现桌面应用与jar包通信。 Java写后端，react写前端。把react写的页面打包放进electron下作为入口文件，放入Java环境下。 整合electron与react框架。使用ipcMain与ipcRenderer实现进程间的通信，ipcMain（主进程）用来获取数据，启动jar获取返回，再将数据返回到ipcRenderer(渲染进程)进行渲染。 &emsp;&emsp;前三种方式都是需要启动服务器端的，对方采用sqlite3做数据库，就是希望在不启动服务器的情况下打开应用，启动jar包，展示数据。因此，第四种方式是最合适的。但是在整合electron与react框架时，出现了很多问题。其中最关键的问题就是整合后react中不能直接使用require引入ipcRenderer。目前网络上查到的解决方案，都是使用window.require引入，同时使用预加载的方式。但是这种方式只适合在不使用进程间通信的情况下使用。下面给出一种我尝试成功的方法，可以使用进程间通信。虽然在开发过程中也出现了很多问题，但是所幸都一一解决了。 0x01 技术路线 技术路线 用途 Electron 构建桌面应用 react 前端页面渲染，展示 ant design React的UI库 sqlite3 一个轻量级的数据库 0x02 环境安装及配置 首先确认已经安装了Nodejs环境，如果没有安装请自行在搜索相关文章进行安装，这里不做详细讲解。 新建项目，打开cmd 123mkdir my-reactcd my-reactnpm init//默认配置就好 安装依赖 1234npm install –save-dev electron electron-prebuilt electron-reload electron-packagernpm install –save-dev babel babelify babel-preset-es2015 babel-preset-react babel-plugin-transform-es2015-spreadnpm install –save-dev browserify watchifynpm install –-save react react-dom react-router-dom &emsp;&emsp;推荐ant design按需加载，因此这里还需要安装babel-plugin-import。12npm install antd --savenpm install –save-dev babel-plugin-import &emsp;&emsp;具体配置和使用请参考ant design官网. 配置.babel &emsp;&emsp;在根目录下新建一个.babelrc文件，内容如下：123456789&#123; &quot;presets&quot;: [ &quot;es2015&quot;, &quot;react&quot; ], &quot;plugins&quot;: [ &quot;transform-object-rest-spread&quot; ]&#125; &emsp;&emsp;这两项用来告知babel转换ES6和React JSX风格的代码，另外还需转换ES6中的spread语法。 代码转换 &emsp;&emsp;package.json 文件中配置 watchify，让其可以自动检测本地代码变化，并且自动转换代码。&emsp;&emsp;scripts 下面配置了三个命令：start、watch、package，分别用于启动 App、检测并转换代码、打包 App。12345&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot;, &quot;watch&quot;: &quot;watchify app/appEntry.js -t babelify -o public/js/bundle.js --debug --verbose&quot;, &quot;package&quot;: &quot;electron-packager ./ DemoApps --overwrite --app-version=1.0.0 --platform=win32 --arch=all --out=../DemoApps --version=1.2.1 --icon=./public/img/app-icon.icns&quot;&#125;, &emsp;&emsp;通过在命令行下执行 npm run xxx ，可以运行上面定义好的命令。我们看到，通过 babelify 将代码转换输出到 public/js/bundle.js 目录下，所以我们发布时只需要这一个转换好的 js 文件即可。 0x03 Electron&emsp;&emsp;package.json文件中有一个”main”字段，这指明了主进程的入口文件。也就是说，启动Electron后会首先在主进程中加载执行这个js文件。所以我们要在这里创建窗口，并在这里指定页面加载的入口文件（index.html）。 index.js 123456789101112131415161718192021222324&apos;use strict&apos;;const electron = require(&apos;electron&apos;);const &#123;app, BrowserWindow, Menu, ipcMain, ipcRenderer&#125; = electron;var mainWnd = null;function createMainWnd() &#123;//创建主进程的窗口 mainWnd = new BrowserWindow(&#123;//长宽可以自定义设置 width: , height: , icon: &apos;public/img/app-icon.png&apos; &#125;); if (isDevelopment) &#123; mainWnd.webContents.openDevTools(); &#125; mainWnd.loadURL(`file://$&#123;__dirname&#125;/index.html`);//加载index.html，打开electron将会显示index.html的内容 mainWnd.on(&apos;closed&apos;, () =&gt; &#123; mainWnd = null; &#125;);&#125;app.on(&apos;ready&apos;, createMainWnd);app.on(&apos;window-all-closed&apos;, () =&gt; &#123; app.quit();&#125;); index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Electron Demo Apps&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;public/css/main.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;/div&gt; &lt;!--引入转换后的js--&gt; &lt;script src=&quot;public/js/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; &emsp;&emsp;这里的id为root的div是一个容器，React组件将会渲染到这个div上面；引入的bundle.js是通过babelify转换生成的js文件。 app/appEmtry.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&apos;use strict&apos;;import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &#123; BrowserRouter as Router, Route, Link, Switch, Redirect&#125; from &apos;react-router-dom&apos;;import Homepage from &apos;./components/Homepage&apos;; // 导入首页组件import Device from &apos;./components/Device&apos;; // 导入设备组件import &#123; Layout, Menu &#125; from &apos;antd&apos;;const &#123; Header, Content, Footer &#125; = Layout;const electron = window.require(&apos;electron&apos;);const &#123; ipcRenderer, shell &#125; = electron;class MainWindow extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;!--这是路由组件--&gt; &lt;Router&gt; &lt;Layout className=&quot;layout&quot;&gt; &#123;/* &lt;div className=&quot;logo&quot; /&gt; */&#125; &lt;Header&gt; &lt;div className=&quot;logo&quot; /&gt; &lt;Menu theme=&quot;dark&quot; mode=&quot;horizontal&quot; defaultSelectedKeys=&#123;[&apos;1&apos;]&#125; style=&#123;&#123; lineHeight: &apos;64px&apos; &#125;&#125; &gt; &lt;Menu.Item key=&quot;1&quot;&gt; &lt;Link to=&quot;/service&quot;&gt;服务&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=&quot;2&quot;&gt; &lt;Link to=&quot;/homepage&quot;&gt;首页&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;/Menu&gt; &lt;/Header&gt; &lt;Content style=&#123;&#123; padding: &apos;0 50px&apos; &#125;&#125;&gt; &lt;div style=&#123;&#123; background: &apos;#fff&apos;, padding: 24, minHeight: 880 &#125;&#125;&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Service&#125;&gt; &lt;/Route&gt; &lt;Route path=&quot;/homepage&quot; component=&#123;Homepage&#125; /&gt; &lt;Redirect to=&quot;/&quot; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Content&gt; &lt;Footer style=&#123;&#123; textAlign: &apos;center&apos; &#125;&#125;&gt; Ant Design ©2018 Created by Ant UED &lt;/Footer&gt; &lt;/Layout&gt; &lt;/Router&gt; ); &#125;&#125;let mainWndComponent = ReactDOM.render( &lt;MainWindow /&gt;, document.querySelector(&apos;#root&apos;)); &emsp;&emsp;需要注意的是，这里的ant design要按需引入；同时为了实现路由，要引入react-router-dom的组件；引入nodejs中文件处理的一些模块；引入electron的渲染进程，用于和主进程进行通信。并通过ReactDOM.render 方法将一个 React 组件渲染到了一个 div 上面。 0x04 sqlite3安装&emsp;&emsp;Electron是基于nodejs的，sqlite3又是一个轻量级数据库。所以这里我们通过在Electron里安装sqlite3的依赖，并引入sqlite3模块来使用它。 &emsp;&emsp;但是在安装过程中会出现很多问题，其中比较多的就是node-gyp未安装的问题。下面给出一个测试正确的方法。1npm install -g node-gyp &emsp;&emsp;使用Microsoft的windows-build-tools，在确认电脑安装了python2.7版本的情况下（python3.0以上版本不支持），以管理员身份运行PowerShell或CMD.exe。使用下面代码安装所有必需的工具和配置。 1npm install --global --production windows-build-tools &emsp;&emsp;最后安装sqlite3.1npm install --save sqlite3 node-gyp的官方网站提供了几种方式. 0x05 启动&emsp;&emsp;首先启动Watchify，主要是让其监控本地文件修改，实时转换生成 public/js/bundle.js 文件。如果appEntry.js转换成bundle.js有错误的话，命令行下也会有提示。1npm run watch &emsp;&emsp;接下来就需要调用start来启动App了。1npm run start 0x06 数据库操作与页面渲染&emsp;&emsp;在这个项目中，我们使用到进程间通信来获取数据，并渲染到页面上。主进程用ipcMain，负责从sqlite3数据库获取数据，再通过与渲染进程ipcrenderer通信，将数据返回给渲染进程，渲染到页面上。 主进程index.js中123456789101112131415161718192021222324252627282930313233ipcMain.on(&apos;getServiceMsg&apos;, (event, arg) =&gt; &#123;//主进程监听一个渲染进程，进行数据库操作 let curpage = arg.curpage; let sql_num = &quot;SELECT * from Info&quot;; let sql_all = &quot;SELECT * from Info limit 1&quot; ; let num; let results = []; db.all(sql_num, function (err, rows) &#123; num = rows.length; &#125;); db.all(sql_all, function (err, rows) &#123; console.log(rows); rows.map((row) =&gt; &#123; results.push(&#123; &quot;key&quot;: row.id, &quot;xinghao&quot;: row.xinghao, &quot;bianhao&quot;: row.bianhao, &quot;wangluohao&quot;: row.wangluohao, &quot;shoujihao&quot;: row.shoujihao, &quot;yuyan&quot;: row.yuyan, &quot;xitongbanben&quot;: row.xitongbanben, &quot;xitongxinghao&quot;: row.xitongxinghao, &quot;changshang&quot;: row.changshang &#125;) &#125;) results.push(&#123; &quot;count&quot;: num, &quot;curpage&quot;: curpage &#125;); // console.log(results); event.returnValue = results;//将从数据库取得的数据返回给渲染进程 &#125;);&#125;) &emsp;&emsp;主进程需要对这个字段进行监听。 渲染进程Homepage.js中1234567891011121314151617181920212223242526272829303132333435export default class Hello extends Component&#123; constructor(props) &#123; super(props); this.state = &#123; dataSource: [], total: &quot;&quot;, curpage: 1, Selected: &quot;&quot; &#125;; &#125; componentDidMount() &#123; this.getMessageData(); &#125; getMessageData() &#123; let data = &#123; &quot;type&quot;:&quot;Info&quot;, &quot;curpage&quot;:this.state.curpage &#125; let res = ipcRenderer.sendSync(&apos;getServiceMsg&apos;, data);//发送给主进程一个字段：&apos;getServiceMsg&apos;，执行数据库查询操作后会获取一个返回值。 let count = res.pop(); this.setState(&#123; dataSource: res[0], total: count.count &#125;, () =&gt; &#123; console.log(this.state.dataSource); &#125;); &#125; onChange(page) &#123; this.setState(&#123; curpage: page.current, &#125;, () =&gt; &#123; this.getMessageData(); &#125;); &#125; render()&#123;&#125; 0x07 开发过程中出现的一些问题 css样式的问题：在用react开发的js文件中引用外部的css文件会报错；antd.css样式不能渲染。这应该是因为babel将appEntry.js转换成bundle.js文件，并没有将css文件转化出来。页面是通过加载index.html进行渲染的，html文件中不能找到css文件。因此，在入口html文件中引入外部css文件。可以解决这个问题。 文件路径问题：文件夹app下存放的是用react开发的js文件，在这里面引入图片时使用相对路径会出错。首先，Homepage与Device两个页面放在app文件夹下的components下，在app文件夹中，js文件的根路径就是app文件夹；因此，引入的图片只能放在app文件夹或下一级目录下；其次，经过babel的转化引起，在bundle.js文件中找不到合适的路径。因此，在引入图片时，我使用了绝对路径或者在整个项目的根目录下写一个css文件，在类中引入图片。 路由的问题：在打开页面时，首页是空白的，只有通过点击导航栏，才会将页面渲染出来。这个问题的解决请参考我前面的博客。 window.require问题：在react中不能直接引入ipcRenderer。这里要使用window.require进行引入，但需要注意的是，打包后的index.html文件为空白，会出现，’window.require is not a function’的报错，使用window.require而不是require来避免electron和browserify的require函数之间的冲突。在浏览器测试的时候会报错，这是因为window.require未在浏览器中定义，只在运行Electron应用程序时起作用。 0x08 打包&emsp;&emsp;关于electron的打包，目前提供了两种打包方式。这里使用的是electron-package。可以参考我的另外一篇博客。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器存储的三种方式------Cookie、localStorage和SessionStorage]]></title>
      <url>%2F2018%2F12%2F04%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-Cookie%E3%80%81localStorage%E5%92%8CSessionStorage%2F</url>
      <content type="text"><![CDATA[0x00 写在前面&emsp;&emsp;这是不得不写的一篇。 0x01 Cookie&emsp;&emsp;当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。Cookie 的作用就是用于解决 “如何记录客户端的用户信息”: 当用户访问 web 页面时，用户名可以记录在 cookie 中。 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。 &emsp;&emsp;Cookie 以名/值对形式存储，当浏览器从服务器上请求 web 页面时， 属于该页面的 cookie 会被添加到该请求中。服务端通过这种方式来获取用户的信息。 1username=John Doe 创建Cookie 123document.cookie=&quot;username=John Doe&quot;;document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT&quot;;//为Cookie创建一个过期时间document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;//使用path参数告诉浏览器Cookie的路径 读取Cookie 1var x = document.cookie;//以字符串的方式返回所有的cookie 修改Cookie 1document.cookie=&quot;username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;//类似于创建Cookie，旧的Cookie将会被覆盖。 删除Cookie &emsp;&emsp;设置express参数为以前的时间。1document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;; 0x02 localStorage&emsp;&emsp;localStorage是HTML5中新加入的特性，用来作为本地存储的，解决了cookie存储空间不足的问题。localStorage 类似于sessionStorage。区别在于: localStorage - 没有时间限制的数据存储 sessionStorage - 针对一个 session 的数据存储,当页面被关闭时,数据存储在sessionStorage 会被清除 。 &emsp;&emsp;localStorage的使用: 清空localStorage 1localStorage.clear() 存储数据 12localStorage.setItem(&quot;name&quot;,&quot;Mark&quot;) localStorage.name = &quot;Mark&quot;; 读取数据 1234localStorage.getItem(&quot;Mark&quot;)//读取保存在localStorage对象里名为name的变量的值localStorage.name //&quot;Mark&quot;localStorage.valueOf()//读取存储在localStorage上的所有数据localStorage.key(0) // 读取第一条数据的变量名(键值) 删除某个变量 1localStorage.removeItem(&quot;name&quot;); //undefined 检查localStorage里是否保存某个变量 12localStorage.hasOwnProperty(&apos;name&apos;) // truelocalStorage.hasOwnProperty(&apos;sex&apos;) // false 将数组转为本地字符串 12345var arr = [&apos;aa&apos;,&apos;bb&apos;,&apos;cc&apos;]; // [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]localStorage.arr = arr //[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]localStorage.arr.toLocaleString(); // &quot;aa,bb,cc&quot; 将JSON存储到localStorage里 123456789101112131415161718192021222324var students = &#123; xiaomin: &#123; name: &quot;xiaoming&quot;, grade: 1 &#125;, teemo: &#123; name: &quot;teemo&quot;, grade: 3 &#125;&#125;students = JSON.stringify(students); //将JSON转为字符串存到变量里console.log(students);localStorage.setItem(&quot;students&quot;,students);//将变量存到localStorage里 var newStudents = localStorage.getItem(&quot;students&quot;);newStudents = JSON.parse(students); //转为JSONconsole.log(newStudents); // 打印出原先对象 0x03 SessionStorage&emsp;&emsp;sessionStorage 是HTML5新增的一个会话存储对象，用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。在JavaScript语言中可通过 window.sessionStorage 或 sessionStorage 调用此对象。 &emsp;&emsp;sessionStorage的使用： 存储数据 12sessionStorage.setItem(&apos;testKey&apos;,&apos;这是一个测试的value值&apos;);//采用setItem()方法存储sessionStorage[&apos;testKey&apos;] = &apos;这是一个测试的value值&apos;;//通过属性方式存储 读取数据 12sessionStorage.getItem(&apos;testKey&apos;); //通过getItem()方法取值、sessionStorage[&apos;testKey&apos;]; // 通过属性方式取值 存储Json对象 &emsp;&emsp;sessionStorage也可存储Json对象：存储时，通过JSON.stringify()将对象转换为文本格式；读取时，通过JSON.parse()将文本转换回对象。 123456789101112var userEntity = &#123; name: &apos;tom&apos;, age: 22&#125;; // 存储值：将对象转换为Json字符串sessionStorage.setItem(&apos;user&apos;, JSON.stringify(userEntity));// 取值时：把获取到的Json字符串转换回对象var userJsonStr = sessionStorage.getItem(&apos;user&apos;);userEntity = JSON.parse(userJsonStr);console.log(userEntity.name); // =&gt; tom 0x04 三者比较 特性 localstorage SessionStorage Cookie 存储空间 5M左右 5M左右 4k，不能超过20个 生命周期 永久 当前会话 在设置的过期时间之前一直有效 与服务器通信 仅在浏览器中保存，不参与和服务器的通话 仅在浏览器中保存，不参与和服务器的通话 携带在HTTP头中,使用过多会导致性能的问题 应用场景 常用于长期登录（判断用户是否已登录） 敏感账号的一次性登录 1.判断用户是否登陆过网站，以便下次登录时能够实现自动登录（记住密码）；2.保存上次登录的时间等信息；3.保存上次查看的页面；4.浏览计数 作用域 不同浏览器无法共享，相同浏览器的不同页面之间可以共享localStorage（页面属于相同域名和端口） 不同浏览器无法共享，不同页面或标签页间无法共享。（当一个标签页包含多个iframe标签且属于同源页面，可以共享） Cookie的作用域为当前设置的域名及其子域名 接口 可以接受原生接口，也可以封装来对Object和Array有更好支持 可以接受原生接口，也可以封装来对Object和Array有更好支持 原生的Cookie接口不友好，需要自己封装setCookie，getCookie &emsp;&emsp;这三者的共同点是：都是保存在浏览器端，且同源的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[create-react-app中使用react-router-dom实现路由跳转]]></title>
      <url>%2F2018%2F12%2F03%2Fcreate-react-app%E4%B8%AD%E4%BD%BF%E7%94%A8react-router-dom%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%2F</url>
      <content type="text"><![CDATA[0x00 写在前面&emsp;&emsp;说来很奇怪，之前用create-react-app写的web网页，结合ant desgin布局写的一个导航栏路由跳转。启动项目之后，首页有数据展示，点击导航栏可以跳转。但是！在整合了electron和react之后，启动项目之后首页空白，默认导航栏位置错误，要人为点击一下才有数据展示。这样用户体验真的真的很不友好。也是查了好久好久才解决了这个问题，于是决定写一篇博客，总结一下react-router-dom。 0x01 react-router-dom的安装与使用&emsp;&emsp;react-router-dom的使用有两种方式。 1. 使用npm1$ npm install --save react-router-dom js文件中1234567// using ES6 modulesimport &#123; BrowserRouter, Route, Link &#125; from &apos;react-router-dom&apos;//推荐使用 // using CommonJS modulesconst BrowserRouter = require(&apos;react-router-dom&apos;).BrowserRouterconst Route = require(&apos;react-router-dom&apos;).Routeconst Link = require(&apos;react-router-dom&apos;).Link 2. 使用unpkg1&lt;script src=&quot;https://unpkg.com/react-router-dom/umd/react-router-dom.min.js&quot;&gt;&lt;/script&gt; &emsp;&emsp;注意的是，这种方式还需要引入react的一些核心文件和依赖文件。不推荐使用这种方式。 0x02 react-router-dom与react-router的区别 react-router: 实现了路由的核心功能 react-router-dom: 基于react-router，加入了在浏览器运行环境下的一些功能，例如：Link组件，会渲染一个a标签，Link组件源码a标签行; BrowserRouter和HashRouter组件，前者使用pushState和popState事件构建路由，后者使用window.location.hash和hashchange事件构建路由。&emsp;&emsp;接下来将介绍react-router-dom的一些组件 0x03 react-router-dom的详细介绍1.HashRouter和BrowserRouter&emsp;&emsp;这两个API两个是路由的基本，需要将它们包裹在最外层，两者只需要选其一。 HashRouter：使用URL的哈希部分（即window.location.hash）的来保持UI与URL同步。注意：哈希历史记录不支持location.key或location.state。如果你使用过react-router2或3或者vue-router，你经常会发现，在浏览器打开页面，其url中会有个#，例如localhost:3000/#，HashRouter就会出现这种情况，它是通过hash值来对路由进行控制。如果使用HashRouter，路由就会默认有这个#。 123&lt;HashRouter&gt; &lt;Route path=&quot;/&quot; componet=&#123;Home&#125;&gt;&lt;/Route&gt;&lt;/HashRouter&gt; 很多情况下不需要这个#，这时就需要用到BrowserRouter。它的原理是使用HTML5历史记录API（pushState，replaceState和popstate事件）的来保持UI与URL的同步， 下面将主要结合它来讲解。如果文件放在服务器的二级目录下就可以使用它。 12345678&lt;BrowserRouter basename=&quot;app&quot; forceRefresh=true getUserConfirmation=window.confirm keyLength=9&gt; &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/BrowserRouter&gt; basename:string。所有位置的基本URL，如果应用程序是从服务器上的子目录提供的，则需要将其设置为子目录。 也就是说，上面例子中的Linkde解析后的href属性为 href=”#/app/about”。 getUserConfirmation：function。用来确认导航功能。默认使用window.confirm。 forceRefresh:bool。如果为true，则路由器将在页面导航中使用全页刷新。可以在不支持HTML5历史记录API的浏览器中使用此功能。 keyLength:number。location.key的长度，默认为6。 children:node。要呈现的单个子元素。 例如”http://localhost:3000/app/&quot;,当主页前面是有一级目录app时，同样要显示主页的内容。这时需要配合Link使用。建议使用BrowserRouter。 2. Route&emsp;&emsp;Route用于控制路径对应显示的组件。常用的有exact、path以及component属性。 exact用于严格匹配，控制匹配到/路径时不会再继续向下匹配； path标识指向的路由路径； component表示要跳转的路径对应的显示组件； &emsp;&emsp;Route会有三大props，分别是location、history、match； history &emsp;&emsp;history 指的是 history 包，它是 React Router 的两个主要依赖之一（除了 React 本身），并且提供了几种不同的实现方式，用于在各种环境中管理 JavaScript 中的会话历史。&emsp;&emsp;history分成以下三种 browser history - 针对 DOM 环境，用于支持 HTML5 history API 的浏览器 hash history - 针对 DOM 环境，用于传统的旧式（低版本） 浏览器 memory history - history 在内存上的实现，用于测试以及 React Native 等非 DOM 环境 &emsp;&emsp;history对象具有以下属性和方法： length - number 历史堆栈中的条目数 action - string 当前的导航操作（push、replace 或 pop） location - object 当前访问的位置信息，见下文 push(path, [state]) - function 将一个新条目推入到历史堆栈中 replace(path, [state]) - function 替换历史堆栈中的当前条目 go(n) - function 将历史堆栈中的指针移动 n 个条目 goBack() - function 返回到上一个页面，相当于 go(-1) goForward() - function 进入到下一个页面，相当于 go(1) block(prompt) - function 阻止导航（请参阅 history 文档） &emsp;&emsp;history 对象是可变的。因此建议从 渲染组件时接收的属性中直接访问 location，而不是通过 history.location 进行访问。这样可以保证 React 在生命周期中的钩子函数正常执行。 1234567componentWillReceiveProps(nextProps) &#123; // true console.log(nextProps.location !== this.props.location); // false，因为 history 是可变的。 console.log(nextProps.history.location !== this.props.history.location);&#125; location &emsp;&emsp;location 代表应用程序的位置。如当前的位置，将要去的位置，或是之前所在的位置。&emsp;&emsp;location具有以下的属性： pathname - string URL 路径 search - string URL 中的查询字符串 hash - string URL 中的 hash 片段 state - object 存储至 location 中的额外状态数据，仅在 browser history 和 memory history 中有效。&emsp;&emsp;Router 将在以下几个地方提供 location 对象： 在 Route component 中，以 this.props.location 方式获取 在 Route render 中，以 ({ location }) =&gt; () 方式获取 在 Route children 中，以 ({ location }) =&gt; () 方式获取 在 withRouter 中，以 this.props.location 方式获取 &emsp;&emsp;location 对象永远不会发生改变，因此可以在生命周期钩子函数中使用 location 对象来查看当前访问地址是否发生改变。12345componentWillReceiveProps(nextProps) &#123; if (nextProps.location !== this.props.location) &#123; // 已经跳转了！ &#125;&#125; match &emsp;&emsp;Match是在使用Router之后被放入props中的一个属性，在class创建的组件中我们需要通过this.props.match来获取match之中的信息。match中包含的信息如下。 params: object 路径参数，通过解析 URL 中的动态部分获得键值对 isExact: bool 为 true 时，整个 URL 都需要匹配 path: string 用来匹配的路径模式，用于创建嵌套的 Route url: string URL 匹配的部分，用于嵌套的 Link &emsp;&emsp;在获取id时经常使用match。 3. Link和NavLink&emsp;&emsp;两者都可以控制路由跳转，不同点是NavLink的api更多。 Link：主要api是to，to可以接受string或者一个object，来控制url，表示路由要跳转的路径。1234567&lt;Link to=&quot;/home&quot; /&gt;&lt;Link to=&#123;&#123; pathname: &apos;/home&apos;, search: &apos;?page=1&apos;, hash: &apos;#the-hash&apos;, state: &#123; fromDashboard: true &#125;&#125;&#125; /&gt; &emsp;&emsp;这时点击Link就会跳转到home页面。 NavLink：它可以为当前选中的路由设置类名、样式以及回调函数等。 12345678910&lt;BrowserRouter&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;NavLink exact activeClassName=&quot;selected&quot; to=&quot;/home/1&quot;&gt;首页&lt;/NavLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;Route path=&quot;/home/:1&quot; componet=&#123;Home&#125;&gt;&lt;/Route&gt;&lt;/BrowserRouter&gt; &emsp;&emsp;exact用于严格匹配，匹配到/则不会继续向下匹配；to则是控制跳转的路径，activeClassName是选中状态的类名，可以为其添加样式。我们通过在/home后面添加1来向路由中传递信息，这结合了上面Route中的/second/:id，线面的1234内容显示需要用到match。 4. Switch&emsp;&emsp;Switch常常会用来包裹Route，它里面不能放其他元素，表示一次只能显示一个路由。用于渲染与路径匹配的第一个子 或 。但与不同的是， 只会渲染一个路由。而定义一系列 时，所有被匹配到的 将都会在页面被渲染出来。12&lt;Route exact path=&quot;/&quot; component=&#123;Service&#125; /&gt;&lt;Route path=&quot;/homepage&quot; component=&#123;Homepage&#125; /&gt; &emsp;&emsp;像这种情况，exact匹配到’/‘就不会再向下匹配，当url为”http://localhost:3000/&quot;时,两个页面都会被匹配到；（匹配不到页面）Switch有两个属性 location: object。用于匹配子元素而不是当前历史位置（通常是当前的浏览器 URL）的 location 对象。 children: node。 的子元素应该是 或 。只有第一个匹配当前路径的组件会被渲染。当 中包含 时，可以使用任何 拥有的路径匹配属性：path、exact 和 strict。from 只是 path 的别名。 5. Redirect&emsp;&emsp;Redirect有四个属性 to:string。链接到的路径名或位置。 to:object。要链接的位置。 push:bool。当为true时，重定向会将新条目推入历史记录，而不是替换当前条目 from:string。要重定向的路径名。用于在内部渲染时匹配位置。 0x04 结合小例子的讲解&emsp;&emsp;在这个小例子中，被放在最外层；的子节点是，表示当前只会渲染一个路由，如果不使用的话，两个组件将会以同时渲染在一个页面上；再接下来是，exact表示精确匹配到’’，只要匹配到’/‘就不会再往下匹配了，这时候就会出现将homepage和device两个页面都匹配到，这种情况下，如果不加Switch，就会按照先后顺序将两个组件都显示到同一个页面上；在加上switch的情况下，也会因为匹配到两个路径中有’/‘的组件而显示空白，这个时候，就需要加上Redirect，只显示第一个被匹配到的路径对应组件的内容。123456789101112131415161718&lt;Menu.Item key=&quot;1&quot;&gt; &lt;Link to=&quot;/service&quot;&gt;设备&lt;/Link&gt;&lt;/Menu.Item&gt;&lt;Menu.Item key=&quot;2&quot;&gt; &lt;Link to=&quot;/homepage&quot;&gt;取证&lt;/Link&gt;&lt;/Menu.Item&gt;&lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Device&#125;&gt; &lt;/Route&gt; &lt;Route path=&quot;/homepage&quot; component=&#123;Homepage&#125; /&gt; &lt;Redirect to=&quot;/&quot; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用setTimeout实现for循环中的计时器]]></title>
      <url>%2F2018%2F09%2F01%2F%E7%94%A8setTimeout%E5%AE%9E%E7%8E%B0for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8%2F</url>
      <content type="text"><![CDATA[写在前面&emsp;&emsp;要实现的功能：在for循环中写一个计时器，先隔2000毫秒打印1，再隔2000毫秒打印2….依次每间隔2000毫秒打印出0到9. 00x1 基本思路&emsp;&emsp;要实现分别输出数组中的所有值，通过简单的for循环就能实现。要实现间隔一段时间输出，则使用setTimeout函数。12345678function test()&#123; for (var i = 0; i &lt; 10; i++) &#123; // setTimeout(function()&#123; console.log(i);//分别输出i的值 // &#125;,2000) &#125; &#125;;test(); &emsp;&emsp;可以在控制台看到紧跟着分别输出了小于10的i的值。但是加上setTimeout函数后，控制台的内容却都变成了10。&emsp;&emsp;解释造成这种差别的原因，我们要从JavaScript的执行机制开始说起。 00x2 js执行机制与作用域链&emsp;&emsp;首先，JavaScript是单线程环境，代码从上到下依次执行。这种执行方这也被称作是“同步执行”。（同一时间JavaScript只能执行一段代码，如果这段代码要执行很长时间，那么之后的代码只能尽情地等待它执行完才能有机会执行）。&emsp;&emsp;但JavaScript中引进了异步机制。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有主线程上的任务执行完了，才通知”任务队列”，任务队列中的任务才会进入主线程执行。 &emsp;&emsp;在上面的代码中，for循环是同步代码，setTimeout是异步代码。遇到这种既包含同步又包含异步的情况，JavaScript依旧按照从上到下的顺序执行同步代码，并将异步代码插入任务队列。setTimeout的第二个参数则是把执行代码（console.log(i)）添加到任务队列需等待的毫秒数，但等待的时间是相对主程序完毕的时间计算的，也就是说，在执行到setTimeout函数时会等待一段时间，再将当前任务插入任务队列。&emsp;&emsp;最后，当执行完同步代码，js引擎就会去执行任务队列中的异步代码。这时候任务队列中就会有十个console.log(i)。我们知道，在每次循环中将setTimeout里面的代码“console.log(i)”放入任务队列时，i的值都是不一样的。但JavaScript引擎开始执行任务队列中的代码时，会开始在当前的作用域中开始找变量i，但是当前作用域中并没有对变量i进行定义。这个时候就会在创造该函数的作用域中寻找i。创建该函数的作用域就是全局作用域，这个时候就找到了for循环中的变量i，这时的i是全局变量，并且值已经确定：10。十个console.log“共享”i的值。这就是作用域链的问题。&emsp;&emsp;为了解决以上两个问题，可以使用let或者闭包或者箭头函数。 00x3 解决方案一——闭包&emsp;&emsp;终于来到了本文中最重要的一部分。什么是闭包？！&emsp;&emsp;闭包是指有权访问另一个函数作用域中的变量的函数。或者说，将函数作为参数或者返回值。创建闭包的常见方式，就是在一个函数内部创建另一个函数。以下面的代码为例。1234567891011function test()&#123; for (var i = 0; i &lt; 10; i++) &#123; (function(j)&#123;//闭包 setTimeout(function()&#123; console.log(j);//分别输出i的值 &#125;,4000) &#125;)(i);//闭包 &#125;; &#125;;test(); &emsp;&emsp;代码中注释为“闭包”的两行代码就是一个典型的闭包。我们在函数内部创建了一个函数，并将变量i以函数参数形式传递给内层函数中变量j，j就是这个函数中的局部变量，每次i传入的值不同，局部变量j的值也不同。 00x4 解决方案二——let&emsp;&emsp;如下面的代码所示，使用let替换var，也能输出0-9的值。这是因为，当for循环中的i是通过var定义的变量时，作用域是一整个封闭函数，是全局作用域；当i是通过let定义的变量时，作用域在代码块中，叫做块级作用域，在for循环这个子块中。12345678function test()&#123; for (let i = 0; i &lt; 10; i++) &#123; setTimeout(function()&#123; console.log(i);//分别输出i的值 &#125;,2000) &#125;;&#125;;test(); 00x5 解决方案三——箭头函数&emsp;&emsp;如下面的代码所示，使用let替换var，也能输出0-9的值。这是因为，当for循环中的i是通过var定义的变量时，作用域是一整个封闭函数，是全局作用域；当i是通过let定义的变量时，作用域在代码块中，叫做块级作用域，在for循环这个子块中。12345678function test()&#123; for (let i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i);//分别输出i的值 &#125;,2000) &#125;;&#125;;test(); 00x5 间隔输出&emsp;&emsp;在实际查看时，控制台并不是一开始就输出i的值，但是也并没有按照预期每隔一段时间输出i的值，问题就出现setTimeout等待的时间上，每次都是2000ms。在任务队列里，setTimeout按照异步的顺序执行，按照放入任务队列的顺序依次开始执行，所以几乎同时打印出值。也就是说，在异步的情况下，执行任务队列里的代码(console.log(i))按照先后顺序执行，没有明显的时间差。可以利用传入的i的值来设置这种时间差。12345678910function test()&#123; for (var i = 0; i &lt; 10; i++) &#123; (function(j)&#123;//闭包 setTimeout(function()&#123; console.log(j);//分别输出i的值 &#125;,2000*j) &#125;)(i);//闭包 &#125;;&#125;;test(); &emsp;&emsp;这样等待的时间就会分别变成20001,20002,2000*3……且传入i的值就立即执行，所以每次打印都会有2000ms的时间差。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[electron与vue实践初体验]]></title>
      <url>%2F2018%2F05%2F24%2Felectron%E4%B8%8Evue%E5%AE%9E%E8%B7%B5%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[写在前面&emsp;&emsp;最近接触了electronjs，官方文档上描述介绍Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，用于构建桌面应用。在开始构建electron或vue之前，默认已经安装了nodejs和git。npm镜像资源索取代理地址在国外，安装速度很慢，这里使用了淘宝提供的镜像cnpm来进行安装。 &emsp;&emsp;使用下面的命令来安装cnpm。1npm install -g cnpm --registry=https://registry.npm.taobao.org//安装cnpm 00x1 构建electron 首先，打开命令行，使用cnpm安装electron。12cnpm install -g electron//在全局安装cnpm install --save-dev electron//在当前目录安装 &emsp;&emsp;这里使用了全局安装方式： 打开git，在github上下载electron-quick-start。1234git clone https://github.com/electron/electron-quick-startcd electron-quick-startcnpm install //安装各种依赖cnpm run start //打开桌面应用 &emsp;&emsp;可以看到一个桌面应用被打开。 00x2 在electron中引入vue 新建一个vue项目 12345cnpm install -g vue-cli//全局安装vue-cli脚手架vue init webpack my-vue(项目名字)//初始化一个项目cd my-vuecnpm install //安装各种依赖npm run dev //打开这个项目 vue打包&emsp;&emsp;打开vue项目中config文件夹下的index.js文件，确认其中的assetsPublicPath修改为相对路径 ./。注意是build配置下的assetsPublicPath。 &emsp;&emsp;运行npm run build对vue项目进行打包，在dist文件夹中生成打包文件。将dist文件夹中生成的static文件夹和index.html放入electron-quick-start下，替换掉electron-quick-start的index.html。1npm run build &emsp;&emsp;再次在electron-quick-start目录中运行npm run start 00x3 打包 在electron-quick-start下安装打包插件 1cnpm install -g electron-packager//采用全局安装 使用electron-packager来进行打包，可以直接使用打包命令 electron-packager &emsp;&emsp;这里的参数: location of project：项目所在路径 name of project：打包的项目名字 platform：确定了你要构建哪个平台的应用（Windows、Mac 还是 Linux） architecture：决定了使用 x86 还是 x64 还是两个架构都用 electron version：electron 的版本 optional options：可选选项 &emsp;&emsp;但是这个命令很长，每次都这样输入会比较麻烦； 可以在package.json下的script下这样写 1&quot;electron_build&quot;: &quot;electron-packager ./ --platform=win32 --arch=x64 --icon=./app/img/electron.ico --overwrite&quot; 打包 1npm run electron_build &emsp;&emsp;运行打包命令就会生成一个文件夹，在里面就能找到打包生成的.exe文件。双击就能运行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongoDB-数据聚合的三种方式]]></title>
      <url>%2F2018%2F03%2F03%2FmongoDB-%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[00x1 group&emsp;&emsp;使用group可以执行相对复杂的聚合，先选定分组所依据的键，而后mongoDB就会将集合依据选定键进行分组，然后对每一个分组内的文档进行聚合，以得到结果文档。（1）group结构 12345678db.test.group(&#123; key:&#123;field:true&#125; //key为分组依据，相当于aggregate中的$group initial:&#123;count:0&#125; //在分组前对变量初始化，这里声明的变量在下面回调函数中作为result的属性使用。 condition://过滤条件，相当于aggregate中的$match。 reduce:function ( curr, result ) &#123;&#125; //第一个参数为当前分组中此时迭代到的文档对象，第二个参数为当前分组 &quot;$keyf&quot;:function() &#123;return &#125; //定义分组函数 finalize:function(result)&#123;&#125; //这里的result为reduce的result，代表当前分组。此函数对完成当前分组后回调。&#125;) &emsp;&emsp;Group有传入的命令中共有六个参数，其中三个是JavaScript函数，因此每次查询到匹配的数据，都会被转换为对象传入函数。从运行效率上来说，Group比Aggregate差一大截。 （2）使用场景&emsp;&emsp;对返回数据最多只包含20000个元素，最多支持20000独立分组。 00x2 aggregate&emsp;&emsp;aggregate是mongoDB中经常提起的“管道”。主要用于处理数据（如求和，统计平均值等），并返回计算后的数据结构。&emsp;&emsp;aggreagte是一个数组，其中包含多个对象（命令），通过遍历Pipleline数组对collection中的数据进行操作。&emsp;&emsp;下面介绍一下aggregate的聚合管道比较常用的几种操作：（1）$project&emsp;&emsp;修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 123456db.testtest.aggregate(&#123; $project:&#123; &quot;_id&quot;:1, &quot;name&quot;:1 &#125;&#125;) （2）$match&emsp;&emsp;用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。12345db.testtest.aggregate(&#123; $match:&#123; &quot;count&quot;:&quot;3&quot;, &#125;&#125;) （3）$limit&emsp;&emsp;用来限制MongoDB聚合管道返回的文档数。123db.testtest.aggregate(&#123; $limit:5&#125;) （4）$skip&emsp;&emsp;在聚合管道中跳过指定数量的文档，并返回余下的文档。123db.testtest.aggregate(&#123; $skip:8&#125;) （5）$unwind&emsp;&emsp;将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。123db.testtest.aggregate(&#123; $unwind:&quot;$identlist&quot;&#125;) （6）$group&emsp;&emsp;将集合中的文档分组，可用于统计结果。123db.testtest.aggregate(&#123; $group:&#123;&quot;_id&quot;:&quot;$count&quot;&#125;&#125;) （7）$sort&emsp;&emsp;将输入文档排序后输出123db.testtest.aggregate(&#123; $sort:&#123;&quot;count&quot;:1&#125;&#125;) （8）使用场景&emsp;&emsp;应用于常用的聚合操作；对聚合响应性能有一定要求时（索引及组合优化）；管道操作在中完成，由于内存有大小限制，处理的数据集大小有限。 00x3 MapReduce（1）MapReduce结构&emsp;&emsp;mapreduce是mongoDB中提供的用于数据聚合的一种方式。通过对集合中的各个满足条件的文档进行预处理，整理出想要的数据然后统计得到最终的统计结果。&emsp;&emsp;mapreduce的结构如下：12345678910111213db.runCommand(&#123; mapreduce:&lt;collection&gt;, //需要进行处理的集合名 map:&lt;mapfunction&gt;, //映射函数（分组） reduce:&lt;reducefunction&gt;, //统计函数 [,query:&lt;query filter object&gt;] //，在发往map函数之前，对文档进行过滤 [,sort:&lt;sorts the input objects using this key.Useful for optimization,like sorting by the emit key for fewer reduces&gt;] //在发往map函数之前，对文档进行排序 [,limit:&lt;number of objects to return from collection&gt;] //限制发往map函数的文档数量 [,out:&lt;see output options below&gt;] //新建集合，用于存放统计结果 [,keeptemp:&lt;true|false&gt;] //是否保存统计结果为临时集合 [,finalize:&lt;finalizefunction&gt;] //最终处理函数，对reduce返回结果（存入out之前）进行最终处理 [,scope:&lt;object where fields go into javascript global scope&gt;] //向map、reduce、finalize导入外部变量 [,verbose:true] //详细的统计信息，用于调试&#125;); &emsp;&emsp;使用MapReduce主要需要实现两个函数：Map函数和Reduce函数。接下来详细介绍这两个函数。（2）Map函数&emsp;&emsp;可以将Map函数理解为分组，调用emit（key，values），遍历collection中所有的记录。其中，emit中的key为分组依据；values为分组后需要保留的数据，为1时则统计该分组的值的个数。&emsp;&emsp;key对应最后结果集中的_id。经过Map函数处理的集合，每条数据中只有”key”和”values”两个字段。 （3）Reduce函数&emsp;&emsp;Reduce为统计函数，接受Map函数处理后返回的key和values作为参数，将key-values变成key-value，也就是把values数组变成一个个单一的value。当key-values中的values数组过大时，会被再切分成很多个小的key-values，再对这些小的key-values分别执行Reduce，再将多个块的结果组合成一个新的数组，作为Reduce函数的第二个参数，继续Reduce操作。这个类似于多阶的归并排序。（4）out和keeptemp&emsp;&emsp;out:&emsp;&emsp;在文档输出时，output是可选的，一般结构为{ “out”: option }。&emsp;&emsp;option可以有以下几个选项。1234&#123; replace : &quot;collection name&quot; &#125; – mapReduce的输出结果会替换掉原来的collection，collection不存在则创建。&#123; merge : &quot;collection name&quot; &#125; – 将新老数据进行合并，新的替换旧的，没有的添加进去。&#123; reduce : &quot;collection name&quot; &#125; – 存在老数据时，在原来基础上加新数据(即 new value = old value + mapReduce value)。&#123; inline : 1 &#125; – 不会创建collection，结果保存在内存里，只限于结果小于16MB的情况。 &emsp;&emsp;通常结构为{“out”:”collection name”}，如果collection不存在，就新建一个集合。 &emsp;&emsp;keeptemp&emsp;&emsp;值只能为true或者false，表明输出到的collection是否是临时的，如果想在连接关闭后任然保留这个集合，则需要指定keeptemp的值为”true”。在使用output的情况下，不必指定keeptemp为true。 （5）使用场景&emsp;&emsp;聚合要求复杂；大型数据集 00x4 三者比较 &emsp; group aggregate MapReduce 是否使用JavaScript引擎 是，定制reduce函数 是，不能编写自定义函数 是，MapReduce函数是用JavaScript编写的 返回结果集保存位置 内联,结果必须符合BSON文档的限制(当前是16Mb) 内联，服务器支持的最大文档大小(16Mb)，超过时会报错 内联、新集合、合并、替换、减少 处理数据集大小 将不会分组到一个超过10,000个键的结果集 操作在内存中完成，有内存大小限制，处理数据集大小有限 大型数据集，超过20000的独立分组建议采用MapReduce 处理性能 低于aggregate 较高，管道可重复使用 低于aggregate 灵活度 低于MapReduce 低于MapRduce 较高，能使用JavaScript 00x5 从一个小例子具体分析&emsp; &emsp; 为公司的每个用户分配一张卡（有唯一的卡号”_id”）；持有该卡的用户可以使用这张卡在不同的超市消费，每个超市都有一个标识码，用”identlist”存放用户消费过的超市标识码；持有该卡的用户名字用”name”表示，默认在该公司中，每个人的姓名都是唯一的，与”_id”一一对应；”eventline”列举用户每次消费购买的物品；”timeline”记录每次消费的时间;”newtimeline”为用户最近一次消费的时间。&emsp; &emsp;示例数据如下：&emsp; &emsp;知道最近有几家超市做促销（数组A），要求（1）获取在A中任意一家或多家超市消费过的卡的持有者；（2）这些卡的最新消费时间；（3）这些卡的累积消费次数；（4）根据最新消费时间/累积消费次数对获取到的这些卡的数据进行排序；对排序后的数据进行分页。&emsp; &emsp;分析：要求中最难的是第一步：遍历数组A，将A中的每一条数据，作为分组依据（可能将原来的一条数据拆分成几条）；再对分组后的数据以”_id”进行聚合。（1）使用MapReduce实现以上要求。 1234567891011121314151617181920212223242526272829var map = function()&#123; emit(this.name,this.timeline); &#125;;var reduce = function(key,values)&#123; return Array.sum(values); &#125;;db.testtest.mapReduce( map, reduce, &#123; query:&#123;$where:function()&#123; var arr = new Array(&quot;Jk3Nx5-YUxBJZ-Zklt&quot;,&quot;LMuHW7-JtnwQC-OBIh&quot;); for(var index in arr)&#123; for(var current in this.identlist)&#123; if(this.identlist[current] == arr[index])&#123; return true; &#125; return false; &#125; &#125; &#125;&#125;, sort:&#123;&quot;count&quot;:1&#125;, finalize:function(key,value)&#123;return &#123;count:value.length,time:value[0]&#125;;&#125;, out:&quot;bbb_result&quot; &#125;)db.bbb_result.find().skip(1).limit(5) （2）使用aggregate123456789101112var arr = new Array(&quot;wdeVyU-YVutsF-CEza&quot;,&quot;Jk3Nx5-YUxBJZ-Zklt&quot;);db.getCollection(&apos;testtest&apos;).aggregate([ &#123;&apos;$unwind&apos;:&quot;$identlist&quot;&#125;, &#123;&quot;$match&quot;:&#123;&quot;identlist&quot;:&#123;&quot;$in&quot;:arr&#125;&#125;&#125;, &#123;$group:&#123;_id:&quot;$name&quot;,timeline:&#123;$addToSet:&quot;$timeline&quot;&#125;&#125;&#125;, &#123;&apos;$unwind&apos;:&quot;$timeline&quot;&#125;, &#123;&apos;$unwind&apos;:&quot;$timeline&quot;&#125;, &#123;$group:&#123;_id:&quot;$_id&quot;,time:&#123;$first:&quot;$timeline&quot;&#125;,count:&#123;&quot;$sum&quot;:1&#125;&#125;&#125;, &#123;$sort:&#123;&quot;count&quot;:-1&#125;&#125;, &#123;$skip:0&#125;, &#123;$limit:5&#125;]) &emsp; &emsp;以上两个小例子经测试后均能实现要求，这里不做详细解释，需要的请自取~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Vue项目中使用Mock.js构造模拟数据]]></title>
      <url>%2F2018%2F03%2F03%2F%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Mock-js%E6%9E%84%E9%80%A0%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[00x1 mockjs简介&emsp;&emsp;mock.js是一款开发前端虚拟接口的插件，主要有两个功能 生成随机数据 拦截Ajax请求00x2 在vue-cli项目中安装配置mockjs &emsp;&emsp;首先确保安装并成功引入axios；&emsp;&emsp;然后安装mockjs npm install mockjs –save-dev；&emsp;&emsp;在main.js文件中引入mockjs并配置axios跨域信息：12345678910111213141516171819202122232425262728293031require(&apos;./mock.js&apos;) //配置axios跨域请求头部axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;//配置axios请求拦截器axios.interceptors.request.use(function(config) &#123; return config; &#125;, function(error) &#123; return Promise.reject(error); &#125;)//配置axios响应拦截器axios.interceptors.response.use(function(response) &#123; return response;&#125;, function(error) &#123; return Promise.reject(error);&#125;)//封装axios的post请求export function fetch(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, params).then(response =&gt; &#123; resolve(response.data); &#125;).catch((error) =&gt; &#123; reject(error); &#125;) &#125;)&#125;//封装接口信息export default &#123; http(url, params) &#123; return fetch(url, params); &#125;&#125; 00x3 Mock.js语法&emsp;&emsp;mock.js语法分为两种，数据模板定义和数据占位符定义 数据模板定义基本结构：属性名|生成规则:属性值1234567（1）&apos;name|min-max&apos;: value（2）&apos;name|count&apos;: value（3）&apos;name|min-max.dmin-dmax&apos;: value（4）&apos;name|min-max.dcount&apos;: value（5）&apos;name|count.dmin-dmax&apos;: value（6）&apos;name|count.dcount&apos;: value（7）&apos;name|+step&apos;: value (1)属性值是字符串String123451. name|min-max: string通过重复string生成一个字符串，重复次数大于等于min，小于等于max。这里的重复是指对初始化string的重复次数。2. name|count: string通过重复string生成一个字符串，重复次数等于count。 (2)属性值是数字Number123456781. name|+1 : number属性值自动加1， 初始值为number2. name|min-max: number生成一个大于等于min，小于等于max的整数。3. name|min-max.dmin-dmax: number生成一个浮点数，整数部分大于等于min，小于等于max，小数部分保留dmin到dmax位。 （3）属性值是布尔类型Boolean123451. name|1: boolean随机生成一个布尔值，值为true的概率为1/2， 值为false的概率为1/2。2. name|min-max: value随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。 （4）属性值是对象Object123451. name|count: object从属性值object中随机选取count个属性2. name|min-max: object从属性值object中随机选取min到max个属性 (5) 属性值是数组Array12345678910111. name|1: array从属性值array中随机选取一个元素，作为最终值2. name|+1: array从属性值array中顺序选取一个元素，作为最终值3. name|min-max: array通过重复属性值array生成一个新数组，重复次数大于等于min，小于等于max。4. name|count: array通过重复属性值array生成一个新数组，重复次数为count。 (6) 属性值是函数Function123&apos;name&apos;: function执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 &apos;name&apos; 所在的对象。 (7) 属性值是正则表达式RegExp121. name: regexp根据正则表达式regexp反向生成可以匹配他的字符串。用于生成自定义格式的字符串。 数据占位符定义基本结构：属性名：占位符1&apos;name|&apos;:&apos;@占位符()&apos; &emsp;&emsp;占位符也可以引用数据模板中的属性；占位符会有限引用数据模板中的属性；占位符支持相对路径和绝对路径。 00x4 Mock.mock() Mock.mock(rurl?, rtype?, template|function(options)) 根据数据模板生成模拟数据 Mock.mock(template) 根据数据模板生成模拟数据。 Mock.mock(rurl, template) 记录数据模板，当拦截到匹配rurl的ajax请求时，根据数据模板生成模拟数据，并作为响应数据返回。 Mock.mock(rurl, function(options)) 记录用于生成响应数据的函数。当拦截到匹配rurl的ajax请求时，函数function执行，并把执行结果作为响应数据返回。 Mock.mock(rurl, rtype, template) 记录数据模板，当拦截到匹配rurl和rtype的ajax请求时，将根据数据模板生成模拟数据，并作为响应数据返回。 Mock.mock(rurl, rtype, function(options)) 记录用于生成响应数据的函数。当拦截到匹配rurl和rtype的ajax请求时，函数function(options)将被执行，并把执行结果作为响应数据返回。 rurl 标识需要拦截的url，可以是url字符串或者url正则： 1/\/domain\/list\.json/、&apos;/domian/list.json&apos;。 rtype 可选，标识需要拦截的ajax请求类型。例如GET, POST, PUT, DELETE等。 template 可选，标识数据模板，可以是对象或字符串。 function(options) 可选，表示用于生成响应数据的函数。 options 指向本次请求的ajax选项集，含有url， type和body三个属性。 00x5 构造模拟数据 &emsp;&emsp;新建一个mock.js文件，在mock.js文件中引入mockjs1const Mock = require(&apos;mockjs&apos;); &emsp;&emsp;根据mock.js语法格式构造模拟数据12345678910111213141516171819202122232425262728export default Mock.mock(&apos;http://test.com&apos;, &#123; &apos;cur_ip&apos;:&#123; &apos;data&apos;:&apos;@date&apos;, &apos;ip&apos;:&apos;@ip&apos;, &apos;number|1-100&apos;:10000, &apos;rank|1-100&apos;:20, &apos;info&apos;:&apos;@title(3)&apos;, &#125;, &apos;cur_whois&apos;:[&#123; &apos;alexa|1-300&apos;:100, &quot;cdate&quot;:&apos;@datetime&apos;, &quot;edate&quot;:&apos;@datetime&apos;, &quot;name_server&quot;:&apos;@domain&apos;, &quot;registrant_address&quot;:&apos;@county(true)&apos;, &quot;registrant_company&quot;:&apos;@ctitle(3, 5)&apos;, &quot;registrant_email&quot;:&apos;@email&apos;, &quot;registrant_name&quot;:&apos;@name(true)&apos;, &quot;registrant_phone&quot;:/^1[0-9]&#123;10&#125;$/, &quot;registrar_name&quot;:&apos;@name(true)&apos;, &quot;udate&quot;:&apos;@datetime&apos;, &#125;], &apos;history_ip|20&apos;:[&#123; &quot;date&quot;:&apos;@datetime&apos;, &quot;ip&quot;:&apos;@ip&apos;, &quot;info&quot;:&apos;@title(3)&apos;, &#125;],&#125;） &emsp;&emsp;mock.js也支持模拟ajax请求响应时间，自定义的响应时间可以是绝对值，也可以是区间。123456Mock.setup(&#123; timeout: 40000//40秒后再响应&#125;)Mock.setup(&#123; timeout: &apos;10000-40000&apos;//在10秒和40秒之间响应&#125;) 00x6 请求获取数据&emsp;&emsp;在需要数据的页面中引入构造的mock的api1import mock from &apos;../main.js&apos; &emsp;&emsp;请求获取数据123mock.http(&apos;http://test.com&apos;, &apos;type=top&amp;key=123456&apos;).then(res =&gt; &#123; console.log(res);&#125;); &emsp;&emsp;完成到这一步后，打开项目就可以看到已经生成的模拟数据，亲测可用。如果只是想了解mockjs语法，可以在打开官网，直接使用示例语法在浏览器控制台上进行测试。 参考：http://mockjs.com/examples.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongoDB安装与配置]]></title>
      <url>%2F2017%2F07%2F26%2FmongoDB%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[00x1 mongodb的安装与配置 (1)在mongodb的官网https://www.mongodb.com/download-center#community 下载安装文件。 进入官网，直接点击donwnload即可。 (2)双击.msi文件安装 (3)创建数据目录 进入mongodb的安装包，创建数据目录 D:\software\mongodb\mkdir data D:\software\mongodb\cd data D:\software\mongodb\data\cd db D:\software\mongodb\data\db\ (4)命令行下运行mongodb服务器 进入mongodb安装目录下的bin文件夹 D:\software\mongodb\bin\mongod.exe --dbpath D:\software\mongodb\data\db 出现下面的内容就表示正确运行了。 当然这一步也有可能出现问题，比如我就遇到了“mongod不是内部或外部命令,也不是可运行的程序”这个问题。 最开始我在环境变量中加入了bin文件夹的路径，但是问题没有解决。 解决方法：直接在bin文件夹中双击打开mongod.exe文件。同样会出现以上的内容。 然后在浏览器中打开http://localhost:27017进行测试。出现下面的内容表示mongodb的服务器正确运行了。 (5)将mongodb安装为windows服务（命令行要有管理员权限） D:\software\mongodb\bin\mongod --dbpath D:\software\mongodb\data --install 但是出现了下面的提示，表明安装失败。 按照提示，需要指定log目录。因此重新切换到bin目录下，新建logs文件。并在logs文件夹下新建mongodb.log文件。 创建日志目录： D:\software\mongodb\mkdir logs D:\software\mongodb\cd logs D:\software\mongodb\logs 然后重新进入bin文件夹，输入命令： D:\software\mongodb\bin\mongod --dbpath D:\software\mongodb\data --logpath=D:\software\mongodb\logs\mongodb.log --logappend. 没有出现错误提示。 也能够正常启动：6.MongoDB后台管理shell（命令行要有管理员权限） 打开 MongoDB shell，失败。 连接失败，net start MongoDB服务，服务不能正常打开，mongo的服务没有被正确创建。 使用sc命令创建mongodb服务，需要注意的是，这一步的cmd必须要以管理员权限打开。 D:\software\mongodb\bin\sc create MongDB binpath=&quot;D:\software\mongo\bin\mongod.exe --service --dbpath D:\software\mongodb\data --logpath=D:\software\mongodb\logs\mongodb.log --logappend 服务创建成功 net start MongoDB 服务也可以正常启动 MongoDB Shell是MongoDB自带的交互式Javascript shell,用来对MongoDB进行操作和管理的交互式环境。可以运行一些简单的算术运算 (7)设置环境变量 进入电脑上的环境变量，在系统变量下的path中加入mongodb目录下的bin文件的路径。 这样命令行就可以在任何位置使用mongodb命令，不需要每次使用mongo和mongod命令的时候都进入 bin文件夹下。 00x2 配置过程中一些命令的总结 在配置过程中，出现问题最多的是将mongodb安装为windows服务，和mongodb后台管理shell这两步骤。在解决这两步的问题时，尝试了不同的命令，在这里做一个总结。 (1)进入bin文件夹下 mongod.exe --bind_ip yourIPadress --logpath &quot;C:\data\dbConf\mongodb.log&quot; --logappend --dbpath &quot;C:\data\db&quot; --port yourPortNumber --serviceName &quot;YourServiceName&quot; --serviceDisplayName &quot;YourServiceName&quot; --install (2)打开具有管理员身份的cmd 如果已经有某个服务名了，比如MongoDB，那么先把这个服务删了， sc delete MongoDB 然后进入mongodb安装目录下的bin文件 mongod --logpath d:\data\log\MongoDB.log --logappend --dbpath d:\data\db --serviceName MongoDB --install (3)同样是进入mongodb安装目录下的bin文件下 mongod --logpath &quot;D:\software\mongodb\data\mongodb.log&quot; --logappend --dbpath &quot;D:\software\mongodb\data&quot; --serviceName &quot;MongoDB&quot; --serviceDisplayName &quot;MongoDB&quot; --install 在解决这部分问题之后，觉得使用这些命令没有成功的原因可能是命令行没有获取管理员权限，还有就是mongdb 的服务没有被正确创建。最正确的创建mongodb服务的方法是使用sc命令进行创建。 D:\software\mongodb\bin\sc create MongDB binpath=&quot;D:\software\mongo\bin\mongod.exe --service --dbpath D:\software\mongodb\data --logpath=D:\software\mongodb\logs\mongodb.log --logappend]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[表单提交类型与ajax]]></title>
      <url>%2F2017%2F04%2F23%2F%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E7%B1%BB%E5%9E%8B%E4%B8%8Eajax%2F</url>
      <content type="text"><![CDATA[00x1 问题描述 在写蜜罐时，遇到了form表单提交的一个问题。使用ajax方式异步提交表单，点击提交按钮后，1.提交页面刷新。ajax使用的是POST方式提交，但是在地址栏出现了GET方式提交才会出现的地址类型。2.数据库中数据成功入库，但是回调函数不显示。 00x2 问题分析及解决数据成功入库，说明ajax提交数据是成功的。而在地址栏中，又出现了GET方式提交才会出现的地址类型，说明表单中的数据应该是被提交了两次，第一次以POST方式（ajax中type设置成“POST”）提交，然后再以GET方式提交。 通过查找资料发现，代码中将button的type设置成了“submit”，将提交按钮的type属性修改成“button”，问题就会解决。submit默认为以GET方式进行表单提交（form）。button则响应用户自定义的事件，如果不指定onclick等事件处理函数，它不做任何事情。以ajax方式提交时，jQuery给提交按钮绑定了click事件，ajax中设定了以POST方式提交。而在button中，type被设置成submit，默认以GET方式提交。就引出了关于click和submit执行先后顺序的问题。 00x3 click和submit执行的先后顺序 点击提交按钮时，是先触发click事件，然后再触发submit事件。这里主要说的是click的处理后续和submit的处理后续：click-&gt;click响应事件-&gt;submit响应事件-&gt;submit。click的处理事件完成后，然后轮到submit事件的处理以及处理后的submit。到这一步，感觉问题就快解决了。但是如果ajax提交表单成功之后，再submit以get方式提交的话。过程中就肯定能看到数据入库后返回的回调函数。就说明，ajax提交并没有完全执行，应该是在向后台提交数据之后和在success返回回调信息之间出现了阻塞。 00x4 同步和异步的区别 在JS中负责解释和执行JavaScript代码的线程只有一个。 这里我们叫做主线程。实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外。我们把它叫做工作线程。主线程发起一个异步请求（提交form表单），相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务（提交form表单到数据库）；工作线程完成工作后，通知主线程（数据成功入库，返回执行结果，并将其放入消息队列）；主线程收到通知后（主线程通过事件循环从消息队列里取消息），执行一定的动作(调用回调函数来处理返回结果) ；触发submit响应（返回值不为FALSE），执行表单的submit事件。又因为给了action的地址，所以会出现跳转。并且在跳转地址中出现GET方式的提交。 在同步情况下，主线程发起一个同步请求（提交form表单），相应的工作线程接收请求并立即开始执行同步任务（提交form表单到数据库）；主线程则一直等待，直到工作线程完工作通知主线程（数据成功入库，返回执行结果，回调函数处理返回结果）。因为返回结果不为FALSE，所以在出现提示之后，出现跳转。 00x5 submit阻止表单提交 参考：ajax同步和异步的区别：http://www.open-open.com/lib/view/open1453079994386.html]]></content>
    </entry>

    
  
  
</search>
